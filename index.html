<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-TW">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="world4jason" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="菜鳥搬磚日常">
<meta property="og:type" content="website">
<meta property="og:title" content="world4jason">
<meta property="og:url" content="https://world4jason.github.io/index.html">
<meta property="og:site_name" content="world4jason">
<meta property="og:description" content="菜鳥搬磚日常">
<meta property="og:locale" content="zh-TW">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="world4jason">
<meta name="twitter:description" content="菜鳥搬磚日常">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://world4jason.github.io/"/>





  <title> world4jason </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-TW">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">world4jason</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">菜鳥搬磚日常</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/06/04/Mask-RCNN-Code-Reading-DetectionLayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/04/Mask-RCNN-Code-Reading-DetectionLayer/" itemprop="url">
                  Mask RCNNCode Reading - Detection Layer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-04T05:57:33+08:00">
                2018-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>這邊其實主要是因為程式碼撰寫方便 所以才拆成Detection Target Layer與Detection Layer 前者是在訓練時用到的,後者是在測試時用的, </p>
<p>Detection Layer</p>
<h2 id="refine-detections-graph"><a href="#refine-detections-graph" class="headerlink" title="refine_detections_graph"></a>refine_detections_graph</h2><p>根據rois和probs(每個ROI都有總類別個數的probs)和deltas進行檢測的優化，得到固定數量的優化目標。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">refine_detections_graph</span><span class="params">(rois, probs, deltas, window, config)</span>:</span></div><div class="line">    <span class="string">"""Refine classified proposals and filter overlaps and return final</span></div><div class="line">    detections.</div><div class="line">    # 輸入為N個rois、N個具有num_classes的probs，scores由probs得出 </div><div class="line">    Inputs:</div><div class="line">        rois: [N, (y1, x1, y2, x2)] in normalized coordinates</div><div class="line">        probs: [N, num_classes]. Class probabilities.</div><div class="line">        deltas: [N, num_classes, (dy, dx, log(dh), log(dw))]. Class-specific</div><div class="line">                bounding box deltas.</div><div class="line">        window: (y1, x1, y2, x2) in image coordinates. The part of the image</div><div class="line">            that contains the image excluding the padding.</div><div class="line"></div><div class="line">    Returns detections shaped: [N, (y1, x1, y2, x2, class_id, score)] where</div><div class="line">        coordinates are normalized.</div><div class="line">    """</div><div class="line">    <span class="comment"># Class IDs per ROI</span></div><div class="line">    class_ids = tf.argmax(probs, axis=<span class="number">1</span>, output_type=tf.int32)</div><div class="line">    <span class="comment"># Class probability of the top class of each ROI</span></div><div class="line">    indices = tf.stack([tf.range(probs.shape[<span class="number">0</span>]), class_ids], axis=<span class="number">1</span>)</div><div class="line">    class_scores = tf.gather_nd(probs, indices)</div><div class="line">    <span class="comment"># Class-specific bounding box deltas</span></div><div class="line">    deltas_specific = tf.gather_nd(deltas, indices)</div><div class="line">    <span class="comment"># Apply bounding box deltas</span></div><div class="line">    <span class="comment"># Shape: [boxes, (y1, x1, y2, x2)] in normalized coordinates</span></div><div class="line">    refined_rois = apply_box_deltas_graph(</div><div class="line">        rois, deltas_specific * config.BBOX_STD_DEV)</div><div class="line">    <span class="comment"># Clip boxes to image window</span></div><div class="line">    refined_rois = clip_boxes_graph(refined_rois, window)</div><div class="line"></div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span> Filter out boxes with zero area</span></div><div class="line"></div><div class="line">    <span class="comment"># Filter out background boxes</span></div><div class="line">    keep = tf.where(class_ids &gt; <span class="number">0</span>)[:, <span class="number">0</span>]</div><div class="line">    <span class="comment"># Filter out low confidence boxes</span></div><div class="line">    <span class="keyword">if</span> config.DETECTION_MIN_CONFIDENCE:</div><div class="line">        conf_keep = tf.where(class_scores &gt;= config.DETECTION_MIN_CONFIDENCE)[:, <span class="number">0</span>]</div><div class="line">        keep = tf.sets.set_intersection(tf.expand_dims(keep, <span class="number">0</span>),</div><div class="line">                                        tf.expand_dims(conf_keep, <span class="number">0</span>))</div><div class="line">        keep = tf.sparse_tensor_to_dense(keep)[<span class="number">0</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># 留下既滿足是前景又滿足scores大於MIN_CONFIDENCE的  </span></div><div class="line">    <span class="comment"># Apply per-class NMS</span></div><div class="line">    <span class="comment"># 1. Prepare variables</span></div><div class="line">    pre_nms_class_ids = tf.gather(class_ids, keep)</div><div class="line">    pre_nms_scores = tf.gather(class_scores, keep)</div><div class="line">    pre_nms_rois = tf.gather(refined_rois,   keep)</div><div class="line">    unique_pre_nms_class_ids = tf.unique(pre_nms_class_ids)[<span class="number">0</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nms_keep_map</span><span class="params">(class_id)</span>:</span></div><div class="line">        <span class="string">"""Apply Non-Maximum Suppression on ROIs of the given class."""</span></div><div class="line">        <span class="comment"># Indices of ROIs of the given class</span></div><div class="line">        ixs = tf.where(tf.equal(pre_nms_class_ids, class_id))[:, <span class="number">0</span>]</div><div class="line">        <span class="comment"># Apply NMS</span></div><div class="line">        class_keep = tf.image.non_max_suppression(</div><div class="line">                tf.gather(pre_nms_rois, ixs),</div><div class="line">                tf.gather(pre_nms_scores, ixs),</div><div class="line">                max_output_size=config.DETECTION_MAX_INSTANCES,</div><div class="line">                iou_threshold=config.DETECTION_NMS_THRESHOLD)</div><div class="line">        <span class="comment"># Map indicies</span></div><div class="line">        class_keep = tf.gather(keep, tf.gather(ixs, class_keep))</div><div class="line">        <span class="comment"># Pad with -1 so returned tensors have the same shape</span></div><div class="line">        gap = config.DETECTION_MAX_INSTANCES - tf.shape(class_keep)[<span class="number">0</span>]</div><div class="line">        class_keep = tf.pad(class_keep, [(<span class="number">0</span>, gap)],</div><div class="line">                            mode=<span class="string">'CONSTANT'</span>, constant_values=<span class="number">-1</span>)</div><div class="line">        <span class="comment"># Set shape so map_fn() can infer result shape</span></div><div class="line">        class_keep.set_shape([config.DETECTION_MAX_INSTANCES])</div><div class="line">        <span class="keyword">return</span> class_keep</div><div class="line"></div><div class="line">    <span class="comment"># 2. Map over class IDs</span></div><div class="line">    <span class="comment"># 在nms_keep_map內分類別的進行NMS。 </span></div><div class="line">    nms_keep = tf.map_fn(nms_keep_map, unique_pre_nms_class_ids,</div><div class="line">                         dtype=tf.int64)</div><div class="line">    <span class="comment"># 3. Merge results into one list, and remove -1 padding</span></div><div class="line">    nms_keep = tf.reshape(nms_keep, [<span class="number">-1</span>])</div><div class="line">    nms_keep = tf.gather(nms_keep, tf.where(nms_keep &gt; <span class="number">-1</span>)[:, <span class="number">0</span>])</div><div class="line">    <span class="comment"># 4. Compute intersection between keep and nms_keep</span></div><div class="line">    keep = tf.sets.set_intersection(tf.expand_dims(keep, <span class="number">0</span>),</div><div class="line">                                    tf.expand_dims(nms_keep, <span class="number">0</span>))</div><div class="line">    keep = tf.sparse_tensor_to_dense(keep)[<span class="number">0</span>]</div><div class="line">    <span class="comment"># Keep top detections</span></div><div class="line">    roi_count = config.DETECTION_MAX_INSTANCES</div><div class="line">    class_scores_keep = tf.gather(class_scores, keep)</div><div class="line">    num_keep = tf.minimum(tf.shape(class_scores_keep)[<span class="number">0</span>], roi_count)</div><div class="line">    top_ids = tf.nn.top_k(class_scores_keep, k=num_keep, sorted=<span class="keyword">True</span>)[<span class="number">1</span>]</div><div class="line">    keep = tf.gather(keep, top_ids)</div><div class="line"></div><div class="line">    <span class="comment"># Arrange output as [N, (y1, x1, y2, x2, class_id, score)]</span></div><div class="line">    <span class="comment"># Coordinates are normalized.</span></div><div class="line">    detections = tf.concat([</div><div class="line">        tf.gather(refined_rois, keep),</div><div class="line">        tf.to_float(tf.gather(class_ids, keep))[..., tf.newaxis],</div><div class="line">        tf.gather(class_scores, keep)[..., tf.newaxis]</div><div class="line">        ], axis=<span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="comment"># Pad with zeros if detections &lt; DETECTION_MAX_INSTANCES</span></div><div class="line">    gap = config.DETECTION_MAX_INSTANCES - tf.shape(detections)[<span class="number">0</span>]</div><div class="line">    detections = tf.pad(detections, [(<span class="number">0</span>, gap), (<span class="number">0</span>, <span class="number">0</span>)], <span class="string">"CONSTANT"</span>)</div><div class="line">    <span class="keyword">return</span> detections</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectionLayer</span><span class="params">(KE.Layer)</span>:</span></div><div class="line">    <span class="string">"""Takes classified proposal boxes and their bounding box deltas and</span></div><div class="line">    returns the final detection boxes.</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    [batch, num_detections, (y1, x1, y2, x2, class_id, class_score)] where</div><div class="line">    coordinates are normalized.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config=None, **kwargs)</span>:</span></div><div class="line">        super(DetectionLayer, self).__init__(**kwargs)</div><div class="line">        self.config = config</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs)</span>:</span></div><div class="line">        rois = inputs[<span class="number">0</span>]</div><div class="line">        mrcnn_class = inputs[<span class="number">1</span>]</div><div class="line">        mrcnn_bbox = inputs[<span class="number">2</span>]</div><div class="line">        image_meta = inputs[<span class="number">3</span>]</div><div class="line"></div><div class="line">        <span class="comment"># Get windows of images in normalized coordinates. Windows are the area</span></div><div class="line">        <span class="comment"># in the image that excludes the padding.</span></div><div class="line">        <span class="comment"># Use the shape of the first image in the batch to normalize the window</span></div><div class="line">        <span class="comment"># because we know that all images get resized to the same size.</span></div><div class="line">        m = parse_image_meta_graph(image_meta)</div><div class="line">        image_shape = m[<span class="string">'image_shape'</span>][<span class="number">0</span>]</div><div class="line">        window = norm_boxes_graph(m[<span class="string">'window'</span>], image_shape[:<span class="number">2</span>])</div><div class="line">        </div><div class="line">        <span class="comment"># Run detection refinement graph on each item in the batch</span></div><div class="line">        detections_batch = utils.batch_slice(</div><div class="line">            [rois, mrcnn_class, mrcnn_bbox, window],</div><div class="line">            <span class="keyword">lambda</span> x, y, w, z: refine_detections_graph(x, y, w, z, self.config),</div><div class="line">            self.config.IMAGES_PER_GPU)</div><div class="line"></div><div class="line">        <span class="comment"># Reshape output</span></div><div class="line">        <span class="comment"># [batch, num_detections, (y1, x1, y2, x2, class_score)] in</span></div><div class="line">        <span class="comment"># normalized coordinates</span></div><div class="line">        <span class="keyword">return</span> tf.reshape(</div><div class="line">            detections_batch,</div><div class="line">            [self.config.BATCH_SIZE, self.config.DETECTION_MAX_INSTANCES, <span class="number">6</span>])</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span><span class="params">(self, input_shape)</span>:</span></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">None</span>, self.config.DETECTION_MAX_INSTANCES, <span class="number">6</span>)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/06/04/Batch-Normalization-and-Group-Normalization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/04/Batch-Normalization-and-Group-Normalization/" itemprop="url">
                  Batch Normalization and Group Normalization
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-04T04:30:09+08:00">
                2018-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Batch Normalization<br>Batch Normalization 在深度學習上算是不可或缺的一部分，基本上所有的框架中都會用到它，我記得比較清楚的是，在YOLOV2中作者採用了Batch Normalization 從而提高了4個百分點的Map吧。</p>
<p>##為何要提出Batch Normalization？<br>在每次給network輸入數據時，都需要進行預處理，比如歸一化之類的，為什麼需要歸一化呢？神經網絡學習過程本質就是為了學習數據分佈，一旦訓練數據與測試數據的分佈不同，那麼網絡的泛化能力也大大降低；另外一方面，一旦每批訓練數據的分佈各不相同(batch 梯度下降)，那麼網絡就要在每次迭代都去學習適應不同的分佈，這樣將會大大降低網絡的訓練速度，這也正是為什麼我們需要對數據都要做一個歸一化預處理的原因。</p>
<p>而且在訓練的過程中，經過一層層的網絡運算，中間層的學習到的數據分佈也是發生著挺大的變化，這就要求我們必須使用一個很小的學習率和對參數很好的初始化，但是這麼做會讓訓練過程變得慢而且複雜m在論文中，這種現象被稱為Internal Covariate Shift。為瞭解決這個問題，作者提出了Batch Normalization。</p>
<p>##Batch Normalization原理<br>為了降低Internal Covariate Shift帶來的影響，其實只要進行歸一化就可以的。比如，我們把network每一層的輸出都整為方差為1，均值為0的正態分佈，這樣看起來是可以解決問題，但是想想，network好不容易學習到的數據特徵，被你這樣一弄又回到瞭解放前了，相當於沒有學習了。所以這樣是不行的，大神想到了一個大招：變換重構，引入了兩個可以學習的參數γ、β，當然，這也是算法的靈魂所在：</p>
<p>具體的算法流程如下：</p>
<p><img src="/media/15280580743313.jpg" alt=""></p>
<p> Batch Normalization 是對一個batch來進行normalization的，例如我們的輸入的一個batch為：β=x_(1…m)，輸出為：y_i=BN(x)。具體的完整流程如下：</p>
<p>1.求出該batch數據x的均值</p>
<p><img src="/media/15280580994379.jpg" alt=""><br>2.求出該batch數據的方差<br><img src="/media/15280581211439.jpg" alt=""><br>3.對輸入數據x做歸一化處理，得到：<br><img src="/media/15280581373757.jpg" alt=""></p>
<p>4.最後加入可訓練的兩個參數：縮放變量γ和平移變量β，計算歸一化後的值：<br><img src="/media/15280581605011.jpg" alt=""><br>加入了這兩個參數之後，網絡就可以更加容易的學習到更多的東西了。先想想極端的情況，當縮放變量γ和平移變量β分別等於batch數據的方差和均值時，最後得到的yi就和原來的xi一模一樣了，相當於batch normalization沒有起作用了。這樣就保證了每一次數據經過歸一化後還保留的有學習來的特徵，同時又能完成歸一化這個操作，加速訓練。</p>
<p>引入參數的更新過程，也就是微積分的Chain Rule：<br><img src="/media/15280581942881.jpg" alt=""></p>
<p>Example</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Batchnorm_simple_for_train</span><span class="params">(x, gamma,beta, bn_param)</span>:</span><span class="string">"""  </span></div><div class="line">param:x   : 輸入數據，設shape(B,L)  </div><div class="line">param:gama : 縮放因子  γ  </div><div class="line">param:beta : 平移因子  β  </div><div class="line">param:bn_param   : batchnorm所需要的一些參數  </div><div class="line">   eps      : 接近0的數，防止分母出現0  </div><div class="line">   momentum : 動量參數，一般為0.9，0.99， 0.999  </div><div class="line">   running_mean ：滑動平均的方式計算新的均值，訓練時計算，為測試數據做準備  </div><div class="line">   running_var  : 滑動平均的方式計算新的方差，訓練時計算，為測試數據做準備  </div><div class="line">"""  </div><div class="line">   running_mean = bn_param[<span class="string">'running_mean'</span>] <span class="comment">#shape = [B]  </span></div><div class="line">   running_var = bn_param[<span class="string">'running_var'</span>]   <span class="comment">#shape = [B]  </span></div><div class="line">   results = <span class="number">0.</span> <span class="comment"># 建立一個新的變量  </span></div><div class="line">   x_mean=x.mean(axis=<span class="number">0</span>)  <span class="comment"># 計算x的均值  </span></div><div class="line">   x_var=x.var(axis=<span class="number">0</span>)    <span class="comment"># 計算方差  </span></div><div class="line">   x_normalized=(x-x_mean)/np.sqrt(x_var+eps)       <span class="comment"># 歸一化  </span></div><div class="line">   results = gamma * x_normalized + beta            <span class="comment"># 縮放平移  </span></div><div class="line">   running_mean = momentum * running_mean + (<span class="number">1</span> - momentum) * x_mean  </div><div class="line">   running_var = momentum * running_var + (<span class="number">1</span> - momentum) * x_var    <span class="comment">#記錄新的值  </span></div><div class="line">   bn_param[<span class="string">'running_mean'</span>] = running_mean  </div><div class="line">   bn_param[<span class="string">'running_var'</span>] = running_var     </div><div class="line">   <span class="keyword">return</span> results , bn_param</div></pre></td></tr></table></figure>
<p>這份code首先計算均值和方差，然後歸一化，然後縮放和平移就結束了！但是這是在訓練中完成的任務，每次訓練給一個批量，然後計算批量的均值方差，但是在測試的時候可不是這樣，測試的時候每次只輸入一張圖片，這怎麼計算批量的均值和方差，於是，就有了代碼中下面兩行，在訓練的時候實現計算好mean var測試的時候直接拿來用就可以了，不用計算均值和方差。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">running_mean = momentum * running_mean + (<span class="number">1</span>- momentum) * x_mean  </div><div class="line">running_var = momentum * running_var + (<span class="number">1</span> -momentum) * x_var</div></pre></td></tr></table></figure>
<p>所以，測試的時候是這樣的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Batchnorm_simple_for_test</span><span class="params">(x, gamma,beta, bn_param)</span>:</span><span class="string">"""  </span></div><div class="line">param:x   : 輸入數據，設shape(B,L)  </div><div class="line">param:gama : 縮放因子  γ  </div><div class="line">param:beta : 平移因子  β  </div><div class="line">param:bn_param   : batchnorm所需要的一些參數  </div><div class="line">   eps      : 接近0的數，防止分母出現0  </div><div class="line">   momentum : 動量參數，一般為0.9，0.99， 0.999  </div><div class="line">   running_mean ：滑動平均的方式計算新的均值，訓練時計算，為測試數據做準備  </div><div class="line">   running_var  : 滑動平均的方式計算新的方差，訓練時計算，為測試數據做準備  </div><div class="line">"""  </div><div class="line">   running_mean = bn_param[<span class="string">'running_mean'</span>] <span class="comment">#shape = [B]  </span></div><div class="line">   running_var = bn_param[<span class="string">'running_var'</span>]   <span class="comment">#shape = [B]  </span></div><div class="line">   results = <span class="number">0.</span> <span class="comment"># 建立一個新的變量  </span></div><div class="line">   x_normalized=(x-running_mean )/np.sqrt(running_var +eps)       <span class="comment"># 歸一化  </span></div><div class="line">   results = gamma * x_normalized + beta            <span class="comment"># 縮放平移  </span></div><div class="line">   <span class="keyword">return</span> results , bn_param</div></pre></td></tr></table></figure>
<p>整個過程還是很順的，很好理解的。這部分的內容摘抄自微信公眾號：機器學習算法工程師。一個很好的公眾號，推薦一波。</p>
<p>Batch Normalization 的TensorFlow 源碼解讀，來自知乎：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_norm_layer</span><span class="params">(x, train_phase,scope_bn)</span>:</span>  </div><div class="line">   <span class="keyword">with</span> tf.variable_scope(scope_bn):  </div><div class="line">        <span class="comment"># 新建兩個變量，平移、縮放因子  </span></div><div class="line">       beta = tf.Variable(tf.constant(<span class="number">0.0</span>, shape=[x.shape[<span class="number">-1</span>]]), name=<span class="string">'beta'</span>,trainable=<span class="keyword">True</span>)  </div><div class="line">       gamma = tf.Variable(tf.constant(<span class="number">1.0</span>, shape=[x.shape[<span class="number">-1</span>]]), name=<span class="string">'gamma'</span>,trainable=<span class="keyword">True</span>)  </div><div class="line">       <span class="comment"># 計算此次批量的均值和方差  </span></div><div class="line">       axises = np.arange(len(x.shape) - <span class="number">1</span>)  </div><div class="line">       batch_mean, batch_var = tf.nn.moments(x, axises, name=<span class="string">'moments'</span>)  </div><div class="line">       <span class="comment"># 滑動平均做衰減  </span></div><div class="line">       ema = tf.train.ExponentialMovingAverage(decay=<span class="number">0.5</span>)  </div><div class="line">       <span class="function"><span class="keyword">def</span> <span class="title">mean_var_with_update</span><span class="params">()</span>:</span>  </div><div class="line">           ema_apply_op = ema.apply([batch_mean, batch_var])  </div><div class="line">           <span class="keyword">with</span> tf.control_dependencies([ema_apply_op]):  </div><div class="line">                <span class="keyword">return</span> tf.identity(batch_mean),tf.identity(batch_var)  </div><div class="line">       <span class="comment"># train_phase 訓練還是測試的flag  </span></div><div class="line">       <span class="comment"># 訓練階段計算runing_mean和runing_var，使用mean_var_with_update（）函數  </span></div><div class="line">       <span class="comment"># 測試的時候直接把之前計算的拿去用 ema.average(batch_mean)  </span></div><div class="line">       mean, var = tf.cond(train_phase, mean_var_with_update,  </div><div class="line">                            <span class="keyword">lambda</span>:(ema.average(batch_mean), ema.average(batch_var)))  </div><div class="line">       normed = tf.nn.batch_normalization(x, mean, var, beta, gamma, <span class="number">1e-3</span>)  </div><div class="line">   <span class="keyword">return</span> normed</div></pre></td></tr></table></figure>
<p>至於此行代碼tf.nn.batch_normalization()就是簡單的計算batchnorm過程，這個函數所實現的功能就如此公式：</p>
<p><img src="/media/15280583334189.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_normalization</span><span class="params">(x, mean, variance, offset,scale, variance_epsilon, name=None)</span>:</span>  </div><div class="line">   <span class="keyword">with</span> ops.name_scope(name, <span class="string">"batchnorm"</span>, [x, mean, variance,scale, offset]):  </div><div class="line">       inv = math_ops.rsqrt(variance + variance_epsilon)  </div><div class="line">    <span class="keyword">if</span> scale <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:  </div><div class="line">           inv *= scale        </div><div class="line">       <span class="keyword">return</span> x * inv + (offset - mean * inv  </div><div class="line">                       <span class="keyword">if</span> offset <span class="keyword">is</span> <span class="keyword">not</span> Noneelse -mean * inv)</div></pre></td></tr></table></figure>
<p>##Batch Normalization的帶來的優勢：</p>
<p>沒有它之前，需要小心的調整學習率和權重初始化，但是有了BN可以放心的使用大學習率，但是使用了BN，就不用小心的調參了，較大的學習率極大的提高了學習速度，</p>
<p>Batchnorm本身上也是一種正則的方式，可以代替其他正則方式如dropout等</p>
<p>另外，個人認為，batchnorm降低了數據之間的絕對差異，有一個去相關的性質，更多的考慮相對差異性，因此在分類任務上具有更好的效果</p>
<p>#Group Normalization<br>group normalization是2018年3月份何愷明大神的又一力作，優化了batch normalization在比較小的batch size 情況下表現不太好的劣勢。批量維度進行歸一化會帶來一些問題——批量統計估算不準確導致批量變小時，BN 的誤差會迅速增加。在訓練大型網絡和將特徵轉移到計算機視覺任務中（包括檢測、分割和視頻），內存消耗限制了只能使用小批量的BN。尤其是在我的破電腦裡面，batch的大小一般都是使用的1，相當於不存在BN。</p>
<p>下圖是論文中給出BN和GN的對比：</p>
<p><img src="/media/15280584129198.jpg" alt=""><br>  可以看出在bath size比較小的情況下，BN的性能十分地差，而GN的性能基本上沒有太大改變。</p>
<p>##Group Normalization 原理：<br>先給出他目前出現比較多的幾種normalization的示意圖：</p>
<p><img src="/media/15280584563207.jpg" alt=""><br>BatchNorm：batch方向做歸一化，算N<em>H</em>W的均值</p>
<p>LayerNorm：channel方向做歸一化，算C<em>H</em>W的均值</p>
<p>InstanceNorm：一個channel內做歸一化，算H*W的均值</p>
<p>GroupNorm：將channel方向分group，然後每個group內做歸一化，算(C//G)<em>H</em>W的均值</p>
<p>從示意圖中看，也可以看出其實沒有太大的變化，所以代碼中也沒有需要太大的變動，只需要稍微修改一下就好了。</p>
<p>GN程式碼範例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">GroupNorm</span><span class="params">(x,G=<span class="number">16</span>,eps=<span class="number">1e-5</span>)</span>:</span>    </div><div class="line">    N,H,W,C=x.shape         </div><div class="line">    x=tf.reshape(x,[tf.cast(N,tf.int32),tf.cast(H,tf.int32),tf.cast(W,tf.int32),tf.cast(G,tf.int32),tf.cast(C//G,tf.int32)])    </div><div class="line">    mean,var=tf.nn.moments(x,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],keep_dims=<span class="keyword">True</span>)    </div><div class="line">    x=(x-mean)/tf.sqrt(var+eps)    </div><div class="line">    x=tf.reshape(x,[tf.cast(N,tf.int32),tf.cast(H,tf.int32),tf.cast(W,tf.int32),tf.cast(C,tf.int32)])    </div><div class="line">    gamma = tf.Variable(tf.ones(shape=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,tf.cast(C,tf.int32)]), name=<span class="string">"gamma"</span>)    </div><div class="line">    beta = tf.Variable(tf.zeros(shape=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,tf.cast(C,tf.int32)]), name=<span class="string">"beta"</span>)    </div><div class="line">    <span class="keyword">return</span> x*gamma+beta</div></pre></td></tr></table></figure>
<h2 id="Group-Normalization-in-Keras"><a href="#Group-Normalization-in-Keras" class="headerlink" title="Group Normalization in Keras"></a>Group Normalization in Keras</h2><p>其實也是在keras中的BatchNormalization層上進行一定的修改就得到了GroupNormalization層。正常和batchnormalization一樣的調用即可。但注意需要保持channel數是group的整數倍。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> keras.engine <span class="keyword">import</span> Layer, InputSpec</div><div class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> initializers</div><div class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> regularizers</div><div class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> constraints</div><div class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</div><div class="line"></div><div class="line"><span class="keyword">from</span> keras.utils.generic_utils <span class="keyword">import</span> get_custom_objects</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupNormalization</span><span class="params">(Layer)</span>:</span></div><div class="line">    <span class="string">"""Group normalization layer</span></div><div class="line"></div><div class="line">    Group Normalization divides the channels into groups and computes within each group</div><div class="line">    the mean and variance for normalization. GN's computation is independent of batch sizes,</div><div class="line">    and its accuracy is stable in a wide range of batch sizes</div><div class="line"></div><div class="line">    # Arguments</div><div class="line">        groups: Integer, the number of groups for Group Normalization.</div><div class="line">        axis: Integer, the axis that should be normalized</div><div class="line">            (typically the features axis).</div><div class="line">            For instance, after a `Conv2D` layer with</div><div class="line">            `data_format="channels_first"`,</div><div class="line">            set `axis=1` in `BatchNormalization`.</div><div class="line">        epsilon: Small float added to variance to avoid dividing by zero.</div><div class="line">        center: If True, add offset of `beta` to normalized tensor.</div><div class="line">            If False, `beta` is ignored.</div><div class="line">        scale: If True, multiply by `gamma`.</div><div class="line">            If False, `gamma` is not used.</div><div class="line">            When the next layer is linear (also e.g. `nn.relu`),</div><div class="line">            this can be disabled since the scaling</div><div class="line">            will be done by the next layer.</div><div class="line">        beta_initializer: Initializer for the beta weight.</div><div class="line">        gamma_initializer: Initializer for the gamma weight.</div><div class="line">        beta_regularizer: Optional regularizer for the beta weight.</div><div class="line">        gamma_regularizer: Optional regularizer for the gamma weight.</div><div class="line">        beta_constraint: Optional constraint for the beta weight.</div><div class="line">        gamma_constraint: Optional constraint for the gamma weight.</div><div class="line"></div><div class="line">    # Input shape</div><div class="line">        Arbitrary. Use the keyword argument `input_shape`</div><div class="line">        (tuple of integers, does not include the samples axis)</div><div class="line">        when using this layer as the first layer in a model.</div><div class="line"></div><div class="line">    # Output shape</div><div class="line">        Same shape as input.</div><div class="line"></div><div class="line">    # References</div><div class="line">        - [Group Normalization](https://arxiv.org/abs/1803.08494)</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></div><div class="line">                 groups=<span class="number">32</span>,</div><div class="line">                 axis=<span class="number">-1</span>,</div><div class="line">                 epsilon=<span class="number">1e-5</span>,</div><div class="line">                 center=True,</div><div class="line">                 scale=True,</div><div class="line">                 beta_initializer=<span class="string">'zeros'</span>,</div><div class="line">                 gamma_initializer=<span class="string">'ones'</span>,</div><div class="line">                 beta_regularizer=None,</div><div class="line">                 gamma_regularizer=None,</div><div class="line">                 beta_constraint=None,</div><div class="line">                 gamma_constraint=None,</div><div class="line">                 **kwargs):</div><div class="line">        super(GroupNormalization, self).__init__(**kwargs)</div><div class="line">        self.supports_masking = <span class="keyword">True</span></div><div class="line">        self.groups = groups</div><div class="line">        self.axis = axis</div><div class="line">        self.epsilon = epsilon</div><div class="line">        self.center = center</div><div class="line">        self.scale = scale</div><div class="line">        self.beta_initializer = initializers.get(beta_initializer)</div><div class="line">        self.gamma_initializer = initializers.get(gamma_initializer)</div><div class="line">        self.beta_regularizer = regularizers.get(beta_regularizer)</div><div class="line">        self.gamma_regularizer = regularizers.get(gamma_regularizer)</div><div class="line">        self.beta_constraint = constraints.get(beta_constraint)</div><div class="line">        self.gamma_constraint = constraints.get(gamma_constraint)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self, input_shape)</span>:</span></div><div class="line">        dim = input_shape[self.axis]</div><div class="line"></div><div class="line">        <span class="keyword">if</span> dim <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Axis '</span> + str(self.axis) + <span class="string">' of '</span></div><div class="line">                                                        <span class="string">'input tensor should have a defined dimension '</span></div><div class="line">                                                        <span class="string">'but the layer received an input with shape '</span> +</div><div class="line">                             str(input_shape) + <span class="string">'.'</span>)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> dim &lt; self.groups:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Number of groups ('</span> + str(self.groups) + <span class="string">') cannot be '</span></div><div class="line">                                                                       <span class="string">'more than the number of channels ('</span> +</div><div class="line">                             str(dim) + <span class="string">').'</span>)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> dim % self.groups != <span class="number">0</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Number of groups ('</span> + str(self.groups) + <span class="string">') must be a '</span></div><div class="line">                                                                       <span class="string">'multiple of the number of channels ('</span> +</div><div class="line">                             str(dim) + <span class="string">').'</span>)</div><div class="line"></div><div class="line">        self.input_spec = InputSpec(ndim=len(input_shape),</div><div class="line">                                    axes=&#123;self.axis: dim&#125;)</div><div class="line">        shape = (dim,)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> self.scale:</div><div class="line">            self.gamma = self.add_weight(shape=shape,</div><div class="line">                                         name=<span class="string">'gamma'</span>,</div><div class="line">                                         initializer=self.gamma_initializer,</div><div class="line">                                         regularizer=self.gamma_regularizer,</div><div class="line">                                         constraint=self.gamma_constraint)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.gamma = <span class="keyword">None</span></div><div class="line">        <span class="keyword">if</span> self.center:</div><div class="line">            self.beta = self.add_weight(shape=shape,</div><div class="line">                                        name=<span class="string">'beta'</span>,</div><div class="line">                                        initializer=self.beta_initializer,</div><div class="line">                                        regularizer=self.beta_regularizer,</div><div class="line">                                        constraint=self.beta_constraint)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.beta = <span class="keyword">None</span></div><div class="line">        self.built = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, **kwargs)</span>:</span></div><div class="line">        input_shape = K.int_shape(inputs)</div><div class="line">        <span class="comment"># Prepare broadcasting shape.</span></div><div class="line">        ndim = len(input_shape)</div><div class="line">        reduction_axes = list(range(len(input_shape)))</div><div class="line">        <span class="keyword">del</span> reduction_axes[self.axis]</div><div class="line">        broadcast_shape = [<span class="number">1</span>] * len(input_shape)</div><div class="line">        broadcast_shape[self.axis] = input_shape[self.axis]</div><div class="line"></div><div class="line">        reshape_group_shape = list(input_shape)</div><div class="line">        reshape_group_shape[self.axis] = input_shape[self.axis] // self.groups</div><div class="line">        group_shape = [<span class="number">-1</span>, self.groups]</div><div class="line">        group_shape.extend(reshape_group_shape[<span class="number">1</span>:])</div><div class="line">        group_reduction_axes = list(range(len(group_shape)))</div><div class="line"></div><div class="line">        <span class="comment"># Determines whether broadcasting is needed.</span></div><div class="line">        needs_broadcasting = (sorted(reduction_axes) != list(range(ndim))[:<span class="number">-1</span>])</div><div class="line"></div><div class="line">        inputs = K.reshape(inputs, group_shape)</div><div class="line"></div><div class="line">        mean = K.mean(inputs, axis=group_reduction_axes[<span class="number">2</span>:], keepdims=<span class="keyword">True</span>)</div><div class="line">        variance = K.var(inputs, axis=group_reduction_axes[<span class="number">2</span>:], keepdims=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">        inputs = (inputs - mean) / (K.sqrt(variance + self.epsilon))</div><div class="line"></div><div class="line">        original_shape = [<span class="number">-1</span>] + list(input_shape[<span class="number">1</span>:])</div><div class="line">        inputs = K.reshape(inputs, original_shape)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> needs_broadcasting:</div><div class="line">            outputs = inputs</div><div class="line"></div><div class="line">            <span class="comment"># In this case we must explicitly broadcast all parameters.</span></div><div class="line">            <span class="keyword">if</span> self.scale:</div><div class="line">                broadcast_gamma = K.reshape(self.gamma, broadcast_shape)</div><div class="line">                outputs = outputs * broadcast_gamma</div><div class="line"></div><div class="line">            <span class="keyword">if</span> self.center:</div><div class="line">                broadcast_beta = K.reshape(self.beta, broadcast_shape)</div><div class="line">                outputs = outputs + broadcast_beta</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            outputs = inputs</div><div class="line"></div><div class="line">            <span class="keyword">if</span> self.scale:</div><div class="line">                outputs = outputs * self.gamma</div><div class="line"></div><div class="line">            <span class="keyword">if</span> self.center:</div><div class="line">                outputs = outputs + self.beta</div><div class="line"></div><div class="line">        <span class="keyword">return</span> outputs</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_config</span><span class="params">(self)</span>:</span></div><div class="line">        config = &#123;</div><div class="line">            <span class="string">'groups'</span>: self.groups,</div><div class="line">            <span class="string">'axis'</span>: self.axis,</div><div class="line">            <span class="string">'epsilon'</span>: self.epsilon,</div><div class="line">            <span class="string">'center'</span>: self.center,</div><div class="line">            <span class="string">'scale'</span>: self.scale,</div><div class="line">            <span class="string">'beta_initializer'</span>: initializers.serialize(self.beta_initializer),</div><div class="line">            <span class="string">'gamma_initializer'</span>: initializers.serialize(self.gamma_initializer),</div><div class="line">            <span class="string">'beta_regularizer'</span>: regularizers.serialize(self.beta_regularizer),</div><div class="line">            <span class="string">'gamma_regularizer'</span>: regularizers.serialize(self.gamma_regularizer),</div><div class="line">            <span class="string">'beta_constraint'</span>: constraints.serialize(self.beta_constraint),</div><div class="line">            <span class="string">'gamma_constraint'</span>: constraints.serialize(self.gamma_constraint)</div><div class="line">        &#125;</div><div class="line">        base_config = super(GroupNormalization, self).get_config()</div><div class="line">        <span class="keyword">return</span> dict(list(base_config.items()) + list(config.items()))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span><span class="params">(self, input_shape)</span>:</span></div><div class="line">        <span class="keyword">return</span> input_shape</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/06/03/Mask-RCNN-Code-Reading-ROI_Align/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/03/Mask-RCNN-Code-Reading-ROI_Align/" itemprop="url">
                  Mask RCNNCode Reading for ROI Align Layer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-03T08:57:33+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ROIAlign-Layer"><a href="#ROIAlign-Layer" class="headerlink" title="ROIAlign Layer"></a>ROIAlign Layer</h2><p>這class在兩個地方會被呼叫到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_fpn_mask_graph</span><span class="params">(rois, feature_maps, image_meta,</span></span></div><div class="line">                         pool_size, num_classes, train_bn=True):</div><div class="line"></div><div class="line">    <span class="comment"># ROI Pooling</span></div><div class="line">    <span class="comment"># Shape: [batch, num_boxes, pool_height, pool_width, channels]</span></div><div class="line">    x = PyramidROIAlign([pool_size, pool_size],</div><div class="line">                        name=<span class="string">"roi_align_mask"</span>)([rois, image_meta] + feature_maps)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fpn_classifier_graph</span><span class="params">(rois, feature_maps, image_meta,</span></span></div><div class="line">                         pool_size, num_classes, train_bn=True):</div><div class="line"></div><div class="line">    <span class="comment"># ROI Pooling</span></div><div class="line">    <span class="comment"># Shape: [batch, num_boxes, pool_height, pool_width, channels]</span></div><div class="line">    x = PyramidROIAlign([pool_size, pool_size],</div><div class="line">                        name=<span class="string">"roi_align_classifier"</span>)([rois, image_meta] + feature_maps)</div></pre></td></tr></table></figure>
<p>ROI獲得的可能會是從P2~P5, 而他們基本上anchors也不太依樣</p>
<p><img src="/media/15280551744304.jpg" alt=""><br>功能型Layer, log2_graph存粹是因為tf 沒有這項功能所以只好自己寫一個.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log2_graph</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="string">"""Implementatin of Log2. TF doesn't have a native implemenation."""</span></div><div class="line">    <span class="keyword">return</span> tf.log(x) / tf.log(<span class="number">2.0</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyramidROIAlign</span><span class="params">(KE.Layer)</span>:</span></div><div class="line">    <span class="string">"""Implements ROI Pooling on multiple levels of the feature pyramid.</span></div><div class="line"></div><div class="line">    Params:</div><div class="line">    - pool_shape: [height, width] of the output pooled regions. Usually [7, 7]</div><div class="line"></div><div class="line">    Inputs:</div><div class="line">    - boxes: [batch, num_boxes, (y1, x1, y2, x2)] in normalized</div><div class="line">             coordinates. Possibly padded with zeros if not enough</div><div class="line">             boxes to fill the array.</div><div class="line">    - image_meta: [batch, (meta data)] Image details. See compose_image_meta()</div><div class="line">    - Feature maps: List of feature maps from different levels of the pyramid.</div><div class="line">                    Each is [batch, height, width, channels]</div><div class="line"></div><div class="line">    Output:</div><div class="line">    Pooled regions in the shape: [batch, num_boxes, height, width, channels].</div><div class="line">    The width and height are those specific in the pool_shape in the layer</div><div class="line">    constructor.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pool_shape, **kwargs)</span>:</span></div><div class="line">        super(PyramidROIAlign, self).__init__(**kwargs)</div><div class="line">        self.pool_shape = tuple(pool_shape)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs)</span>:</span></div><div class="line">        <span class="comment"># Crop boxes [batch, num_boxes, (y1, x1, y2, x2)] in normalized coords</span></div><div class="line">        <span class="comment"># inputs[0 is ROIs]</span></div><div class="line">        boxes = inputs[<span class="number">0</span>]</div><div class="line"></div><div class="line">        <span class="comment"># Image meta</span></div><div class="line">        <span class="comment"># Holds details about the image. See compose_image_meta()</span></div><div class="line">        image_meta = inputs[<span class="number">1</span>]</div><div class="line"></div><div class="line">        <span class="comment"># Feature Maps. List of feature maps from different level of the</span></div><div class="line">        <span class="comment"># feature pyramid. Each is [batch, height, width, channels]</span></div><div class="line">        feature_maps = inputs[<span class="number">2</span>:]</div><div class="line"></div><div class="line">        <span class="comment"># Assign each ROI to a level in the pyramid based on the ROI area.</span></div><div class="line">        y1, x1, y2, x2 = tf.split(boxes, <span class="number">4</span>, axis=<span class="number">2</span>)</div><div class="line">        h = y2 - y1</div><div class="line">        w = x2 - x1</div><div class="line">        <span class="comment"># Use shape of first image. Images in a batch must have the same size.</span></div><div class="line">        image_shape = parse_image_meta_graph(image_meta)[<span class="string">'image_shape'</span>][<span class="number">0</span>]</div><div class="line">        <span class="comment"># Equation 1 in the Feature Pyramid Networks paper. Account for</span></div><div class="line">        <span class="comment"># the fact that our coordinates are normalized here.</span></div><div class="line">        <span class="comment"># e.g. a 224x224 ROI (in pixels) maps to P4</span></div><div class="line">        image_area = tf.cast(image_shape[<span class="number">0</span>] * image_shape[<span class="number">1</span>], tf.float32)</div><div class="line">        roi_level = log2_graph(tf.sqrt(h * w) / (<span class="number">224.0</span> / tf.sqrt(image_area)))</div><div class="line">        roi_level = tf.minimum(<span class="number">5</span>, tf.maximum(</div><div class="line">            <span class="number">2</span>, <span class="number">4</span> + tf.cast(tf.round(roi_level), tf.int32)))</div><div class="line">        roi_level = tf.squeeze(roi_level, <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># Loop through levels and apply ROI pooling to each. P2 to P5.</span></div><div class="line">        pooled = []</div><div class="line">        box_to_level = []</div><div class="line">        <span class="keyword">for</span> i, level <span class="keyword">in</span> enumerate(range(<span class="number">2</span>, <span class="number">6</span>)):</div><div class="line">            <span class="comment">##應該是一個二維的array，存儲這哪一層的哪些box的indicies  </span></div><div class="line">            ix = tf.where(tf.equal(roi_level, level))</div><div class="line">            level_boxes = tf.gather_nd(boxes, ix)</div><div class="line"></div><div class="line">            <span class="comment"># Box indicies for crop_and_resize.</span></div><div class="line">            box_indices = tf.cast(ix[:, <span class="number">0</span>], tf.int32)</div><div class="line"></div><div class="line">            <span class="comment"># Keep track of which box is mapped to which level</span></div><div class="line">            <span class="comment">##應該是一個二維的array，存儲這哪一層的哪些box的indicies  </span></div><div class="line"></div><div class="line">            box_to_level.append(ix)</div><div class="line"></div><div class="line">            <span class="comment"># Stop gradient propogation to ROI proposals</span></div><div class="line">            level_boxes = tf.stop_gradient(level_boxes)</div><div class="line">            box_indices = tf.stop_gradient(box_indices)</div><div class="line"></div><div class="line">            <span class="comment"># Crop and Resize</span></div><div class="line">            <span class="comment"># From Mask R-CNN paper: "We sample four regular locations, so</span></div><div class="line">            <span class="comment"># that we can evaluate either max or average pooling. In fact,</span></div><div class="line">            <span class="comment"># interpolating only a single value at each bin center (without</span></div><div class="line">            <span class="comment"># pooling) is nearly as effective."</span></div><div class="line">            <span class="comment">#</span></div><div class="line">            <span class="comment"># Here we use the simplified approach of a single value per bin,</span></div><div class="line">            <span class="comment"># which is how it's done in tf.crop_and_resize()</span></div><div class="line">            <span class="comment"># Result: [batch * num_boxes, pool_height, pool_width, channels]</span></div><div class="line">            <span class="comment"># 因為插值一個點和四個點的性能影響不大故插一個點 </span></div><div class="line">            pooled.append(tf.image.crop_and_resize(</div><div class="line">                feature_maps[i], level_boxes, box_indices, self.pool_shape,</div><div class="line">                method=<span class="string">"bilinear"</span>))</div><div class="line"></div><div class="line">        <span class="comment"># Pack pooled features into one tensor</span></div><div class="line">        pooled = tf.concat(pooled, axis=<span class="number">0</span>)</div><div class="line"></div><div class="line">        <span class="comment"># Pack box_to_level mapping into one array and add another</span></div><div class="line">        <span class="comment"># column representing the order of pooled boxes</span></div><div class="line">        box_to_level = tf.concat(box_to_level, axis=<span class="number">0</span>)</div><div class="line">        box_range = tf.expand_dims(tf.range(tf.shape(box_to_level)[<span class="number">0</span>]), <span class="number">1</span>)</div><div class="line">        box_to_level = tf.concat([tf.cast(box_to_level, tf.int32), box_range],</div><div class="line">                                 axis=<span class="number">1</span>)</div><div class="line"></div><div class="line">        <span class="comment"># Rearrange pooled features to match the order of the original boxes</span></div><div class="line">        <span class="comment"># Sort box_to_level by batch then box index</span></div><div class="line">        <span class="comment"># TF doesn't have a way to sort by two columns, so merge them and sort.</span></div><div class="line">        sorting_tensor = box_to_level[:, <span class="number">0</span>] * <span class="number">100000</span> + box_to_level[:, <span class="number">1</span>]</div><div class="line">        ix = tf.nn.top_k(sorting_tensor, k=tf.shape(</div><div class="line">            box_to_level)[<span class="number">0</span>]).indices[::<span class="number">-1</span>]</div><div class="line">        ix = tf.gather(box_to_level[:, <span class="number">2</span>], ix)</div><div class="line">        pooled = tf.gather(pooled, ix)</div><div class="line"></div><div class="line">        <span class="comment"># Re-add the batch dimension</span></div><div class="line">        pooled = tf.expand_dims(pooled, <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> pooled</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span><span class="params">(self, input_shape)</span>:</span></div><div class="line">        <span class="keyword">return</span> input_shape[<span class="number">0</span>][:<span class="number">2</span>] + self.pool_shape + (input_shape[<span class="number">2</span>][<span class="number">-1</span>], )</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/06/03/Mask-RCNN-Code-Reading-DetectionTargetLayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/03/Mask-RCNN-Code-Reading-DetectionTargetLayer/" itemprop="url">
                  Mask RCNNCode Reading - Detection Target Layer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-03T06:57:33+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Detection Target Layer與Detection Layer 前者是在訓練時用到的<br>後者是在測試時用的</p>
<p>其實對於inference來說,Proposal_Layer已經拿到要的結果了, DetectionTargetLayer最主要是訓練用途需要 所以會有ground truth (gt_box, gt_class_id, gt_mask)</p>
<h3 id="overlaps-graph"><a href="#overlaps-graph" class="headerlink" title="overlaps_graph"></a>overlaps_graph</h3><p>這邊顧名思義是計算IOU用的,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">overlaps_graph</span><span class="params">(boxes1, boxes2)</span>:</span></div><div class="line">    <span class="string">"""Computes IoU overlaps between two sets of boxes.</span></div><div class="line">    boxes1, boxes2: [N, (y1, x1, y2, x2)].</div><div class="line">    """</div><div class="line">    <span class="comment"># 1. Tile boxes2 and repeat boxes1. This allows us to compare</span></div><div class="line">    <span class="comment"># every boxes1 against every boxes2 without loops.</span></div><div class="line">    <span class="comment"># TF doesn't have an equivalent to np.repeat() so simulate it</span></div><div class="line">    <span class="comment"># using tf.tile() and tf.reshape.</span></div><div class="line">    b1 = tf.reshape(tf.tile(tf.expand_dims(boxes1, <span class="number">1</span>),</div><div class="line">                            [<span class="number">1</span>, <span class="number">1</span>, tf.shape(boxes2)[<span class="number">0</span>]]), [<span class="number">-1</span>, <span class="number">4</span>])</div><div class="line">    b2 = tf.tile(boxes2, [tf.shape(boxes1)[<span class="number">0</span>], <span class="number">1</span>])</div><div class="line">    <span class="comment"># 2. Compute intersections</span></div><div class="line">    b1_y1, b1_x1, b1_y2, b1_x2 = tf.split(b1, <span class="number">4</span>, axis=<span class="number">1</span>)</div><div class="line">    b2_y1, b2_x1, b2_y2, b2_x2 = tf.split(b2, <span class="number">4</span>, axis=<span class="number">1</span>)</div><div class="line">    y1 = tf.maximum(b1_y1, b2_y1)</div><div class="line">    x1 = tf.maximum(b1_x1, b2_x1)</div><div class="line">    y2 = tf.minimum(b1_y2, b2_y2)</div><div class="line">    x2 = tf.minimum(b1_x2, b2_x2)</div><div class="line">    intersection = tf.maximum(x2 - x1, <span class="number">0</span>) * tf.maximum(y2 - y1, <span class="number">0</span>)</div><div class="line">    <span class="comment"># 3. Compute unions</span></div><div class="line">    b1_area = (b1_y2 - b1_y1) * (b1_x2 - b1_x1)</div><div class="line">    b2_area = (b2_y2 - b2_y1) * (b2_x2 - b2_x1)</div><div class="line">    union = b1_area + b2_area - intersection</div><div class="line">    <span class="comment"># 4. Compute IoU and reshape to [boxes1, boxes2]</span></div><div class="line">    iou = intersection / union</div><div class="line">    overlaps = tf.reshape(iou, [tf.shape(boxes1)[<span class="number">0</span>], tf.shape(boxes2)[<span class="number">0</span>]])</div><div class="line">    <span class="keyword">return</span> overlaps</div></pre></td></tr></table></figure>
<h3 id="Detection-Target-Layer"><a href="#Detection-Target-Layer" class="headerlink" title="Detection Target Layer"></a>Detection Target Layer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectionTargetLayer</span><span class="params">(KE.Layer)</span>:</span></div><div class="line">    <span class="string">"""Subsamples proposals and generates target box refinement, class_ids,</span></div><div class="line">    and masks for each.</div><div class="line"></div><div class="line">    Inputs:</div><div class="line">    proposals: [batch, N, (y1, x1, y2, x2)] in normalized coordinates. Might</div><div class="line">               be zero padded if there are not enough proposals.</div><div class="line">    gt_class_ids: [batch, MAX_GT_INSTANCES] Integer class IDs.</div><div class="line">    gt_boxes: [batch, MAX_GT_INSTANCES, (y1, x1, y2, x2)] in normalized</div><div class="line">              coordinates.</div><div class="line">    gt_masks: [batch, height, width, MAX_GT_INSTANCES] of boolean type</div><div class="line"></div><div class="line">    Returns: Target ROIs and corresponding class IDs, bounding box shifts,</div><div class="line">    and masks.</div><div class="line">    rois: [batch, TRAIN_ROIS_PER_IMAGE, (y1, x1, y2, x2)] in normalized</div><div class="line">          coordinates</div><div class="line">    target_class_ids: [batch, TRAIN_ROIS_PER_IMAGE]. Integer class IDs.</div><div class="line">    target_deltas: [batch, TRAIN_ROIS_PER_IMAGE, NUM_CLASSES,</div><div class="line">                    (dy, dx, log(dh), log(dw), class_id)]</div><div class="line">                   Class-specific bbox refinements.</div><div class="line">    target_mask: [batch, TRAIN_ROIS_PER_IMAGE, height, width)</div><div class="line">                 Masks cropped to bbox boundaries and resized to neural</div><div class="line">                 network output size.</div><div class="line"></div><div class="line">    Note: Returned arrays might be zero padded if not enough target ROIs.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config, **kwargs)</span>:</span></div><div class="line">        super(DetectionTargetLayer, self).__init__(**kwargs)</div><div class="line">        self.config = config</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs)</span>:</span></div><div class="line">        proposals = inputs[<span class="number">0</span>]</div><div class="line">        gt_class_ids = inputs[<span class="number">1</span>]</div><div class="line">        gt_boxes = inputs[<span class="number">2</span>]</div><div class="line">        gt_masks = inputs[<span class="number">3</span>]</div><div class="line"></div><div class="line">        <span class="comment"># Slice the batch and run a graph for each slice</span></div><div class="line">        <span class="comment"># <span class="doctag">TODO:</span> Rename target_bbox to target_deltas for clarity</span></div><div class="line">        names = [<span class="string">"rois"</span>, <span class="string">"target_class_ids"</span>, <span class="string">"target_bbox"</span>, <span class="string">"target_mask"</span>]</div><div class="line">        outputs = utils.batch_slice(</div><div class="line">            [proposals, gt_class_ids, gt_boxes, gt_masks],</div><div class="line">            <span class="keyword">lambda</span> w, x, y, z: detection_targets_graph(</div><div class="line">                w, x, y, z, self.config),</div><div class="line">            self.config.IMAGES_PER_GPU, names=names)</div><div class="line">        <span class="keyword">return</span> outputs</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span><span class="params">(self, input_shape)</span>:</span></div><div class="line">        <span class="keyword">return</span> [</div><div class="line">            (<span class="keyword">None</span>, self.config.TRAIN_ROIS_PER_IMAGE, <span class="number">4</span>),  <span class="comment"># rois</span></div><div class="line">            (<span class="keyword">None</span>, <span class="number">1</span>),  <span class="comment"># class_ids</span></div><div class="line">            (<span class="keyword">None</span>, self.config.TRAIN_ROIS_PER_IMAGE, <span class="number">4</span>),  <span class="comment"># deltas</span></div><div class="line">            (<span class="keyword">None</span>, self.config.TRAIN_ROIS_PER_IMAGE, self.config.MASK_SHAPE[<span class="number">0</span>],</div><div class="line">             self.config.MASK_SHAPE[<span class="number">1</span>])  <span class="comment"># masks</span></div><div class="line">        ]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_mask</span><span class="params">(self, inputs, mask=None)</span>:</span></div><div class="line">        <span class="keyword">return</span> [<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>]</div></pre></td></tr></table></figure>
<h3 id="detection-targets-graph"><a href="#detection-targets-graph" class="headerlink" title="detection_targets_graph"></a>detection_targets_graph</h3><p>detection_targets_graph函數負責處理輸入的[proposals, gt_class_ids, gt_boxes, gt_masks]</p>
<p>Code有點長，首先計算proposals和gt_boxes的覆蓋度矩陣proposals*gt_boxes，然後獲得每個proposals一個與gt_boxes最大覆蓋度值roi_iou_max，如果roi_iou_max&gt;0.5，則認為該proposals是positive_roi，最後再把對應gt_box分配給對應的positive_roi並進行框體微調獲得對應偏移。最終返回的rois包含positive_roi和negative_roi。</p>
<p>根據proposal和gt_box的overlap來確定正樣本和負樣本，並按照sample_ratio和train_anchor_per_image的大小進行sample，最終得出rois, class_id,delta,masks，其中進行了padding  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">detection_targets_graph</span><span class="params">(proposals, gt_class_ids, gt_boxes, gt_masks, config)</span>:</span></div><div class="line">    <span class="string">"""Generates detection targets for one image. Subsamples proposals and</span></div><div class="line">    generates target class IDs, bounding box deltas, and masks for each.</div><div class="line"></div><div class="line">    Inputs:</div><div class="line">    proposals: [N, (y1, x1, y2, x2)] in normalized coordinates. Might</div><div class="line">               be zero padded if there are not enough proposals.</div><div class="line">    gt_class_ids: [MAX_GT_INSTANCES] int class IDs</div><div class="line">    gt_boxes: [MAX_GT_INSTANCES, (y1, x1, y2, x2)] in normalized coordinates.</div><div class="line">    gt_masks: [height, width, MAX_GT_INSTANCES] of boolean type.</div><div class="line"></div><div class="line">    Returns: Target ROIs and corresponding class IDs, bounding box shifts,</div><div class="line">    and masks.</div><div class="line">    rois: [TRAIN_ROIS_PER_IMAGE, (y1, x1, y2, x2)] in normalized coordinates</div><div class="line">    class_ids: [TRAIN_ROIS_PER_IMAGE]. Integer class IDs. Zero padded.</div><div class="line">    deltas: [TRAIN_ROIS_PER_IMAGE, NUM_CLASSES, (dy, dx, log(dh), log(dw))]</div><div class="line">            Class-specific bbox refinements.</div><div class="line">    masks: [TRAIN_ROIS_PER_IMAGE, height, width). Masks cropped to bbox</div><div class="line">           boundaries and resized to neural network output size.</div><div class="line"></div><div class="line">    Note: Returned arrays might be zero padded if not enough target ROIs.</div><div class="line">    """</div><div class="line">    <span class="comment"># Assertions</span></div><div class="line">    asserts = [ tf.Assert(tf.greater(tf.shape(proposals)[<span class="number">0</span>], <span class="number">0</span>), [proposals],name=<span class="string">"roi_assertion"</span>),]</div><div class="line">    <span class="keyword">with</span> tf.control_dependencies(asserts):</div><div class="line">        proposals = tf.identity(proposals)</div><div class="line"></div><div class="line">    <span class="comment"># Remove zero padding</span></div><div class="line">    <span class="comment"># 去除0的padding</span></div><div class="line">    proposals, _ = trim_zeros_graph(proposals, name=<span class="string">"trim_proposals"</span>)</div><div class="line">    gt_boxes, non_zeros = trim_zeros_graph(gt_boxes, name=<span class="string">"trim_gt_boxes"</span>)</div><div class="line">    gt_class_ids = tf.boolean_mask(gt_class_ids, non_zeros,</div><div class="line">                                   name=<span class="string">"trim_gt_class_ids"</span>)</div><div class="line">    gt_masks = tf.gather(gt_masks, tf.where(non_zeros)[:, <span class="number">0</span>], axis=<span class="number">2</span>,</div><div class="line">                         name=<span class="string">"trim_gt_masks"</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># 有點看不懂 反正是處理coco的問題的樣子</span></div><div class="line">    <span class="comment"># Handle COCO crowds</span></div><div class="line">    <span class="comment"># A crowd box in COCO is a bounding box around several instances. Exclude</span></div><div class="line">    <span class="comment"># them from training. A crowd box is given a negative class ID.</span></div><div class="line">    crowd_ix = tf.where(gt_class_ids &lt; <span class="number">0</span>)[:, <span class="number">0</span>]</div><div class="line">    non_crowd_ix = tf.where(gt_class_ids &gt; <span class="number">0</span>)[:, <span class="number">0</span>]</div><div class="line">    crowd_boxes = tf.gather(gt_boxes, crowd_ix)</div><div class="line">    crowd_masks = tf.gather(gt_masks, crowd_ix, axis=<span class="number">2</span>)</div><div class="line">    gt_class_ids = tf.gather(gt_class_ids, non_crowd_ix)</div><div class="line">    gt_boxes = tf.gather(gt_boxes, non_crowd_ix)</div><div class="line">    gt_masks = tf.gather(gt_masks, non_crowd_ix, axis=<span class="number">2</span>)</div><div class="line"></div><div class="line">    <span class="comment"># Compute overlaps matrix [proposals, gt_boxes]</span></div><div class="line">        overlaps = overlaps_graph(proposals, gt_boxes)</div><div class="line"></div><div class="line">    <span class="comment"># Compute overlaps with crowd boxes [anchors, crowds]</span></div><div class="line">    crowd_overlaps = overlaps_graph(proposals, crowd_boxes)</div><div class="line">    crowd_iou_max = tf.reduce_max(crowd_overlaps, axis=<span class="number">1</span>)</div><div class="line">    no_crowd_bool = (crowd_iou_max &lt; <span class="number">0.001</span>)</div><div class="line"></div><div class="line">    <span class="comment"># Determine postive and negative ROIs</span></div><div class="line">    <span class="comment"># 獲得proposals和gt_box最大overlaps的值[n_proposals,1]</span></div><div class="line">    roi_iou_max = tf.reduce_max(overlaps, axis=<span class="number">1</span>)</div><div class="line">    <span class="comment"># 1. Positive ROIs are those with &gt;= 0.5 IoU with a GT box</span></div><div class="line">    <span class="comment"># roi覆蓋度值&gt;0.5則認為其是positive_roi bool[n_proposals,1]</span></div><div class="line">    positive_roi_bool = (roi_iou_max &gt;= <span class="number">0.5</span>)</div><div class="line">    <span class="comment"># 拿positive_roi的index [filter_n_proposals,1]</span></div><div class="line">    positive_indices = tf.where(positive_roi_bool)[:, <span class="number">0</span>]</div><div class="line">    <span class="comment"># 2. Negative ROIs are those with &lt; 0.5 with every GT box. Skip crowds.</span></div><div class="line">    negative_indices = tf.where(tf.logical_and(roi_iou_max &lt; <span class="number">0.5</span>, no_crowd_bool))[:, <span class="number">0</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># 對positive_roi和negative_roi進行了subsample</span></div><div class="line">    <span class="comment"># Subsample ROIs. Aim for 33% positive</span></div><div class="line">    <span class="comment"># Positive ROIs</span></div><div class="line">    positive_count = int(config.TRAIN_ROIS_PER_IMAGE *</div><div class="line">                         config.ROI_POSITIVE_RATIO)</div><div class="line">    positive_indices = tf.random_shuffle(positive_indices)[:positive_count]</div><div class="line">    positive_count = tf.shape(positive_indices)[<span class="number">0</span>]</div><div class="line">    <span class="comment"># Negative ROIs. Add enough to maintain positive:negative ratio.</span></div><div class="line">    r = <span class="number">1.0</span> / config.ROI_POSITIVE_RATIO</div><div class="line">    negative_count = tf.cast(r * tf.cast(positive_count, tf.float32), tf.int32) - positive_count</div><div class="line">    negative_indices = tf.random_shuffle(negative_indices)[:negative_count]</div><div class="line">    <span class="comment"># Gather selected ROIs</span></div><div class="line">    positive_rois = tf.gather(proposals, positive_indices)</div><div class="line">    negative_rois = tf.gather(proposals, negative_indices)</div><div class="line"></div><div class="line">    <span class="comment"># Assign positive ROIs to GT boxes.</span></div><div class="line">    <span class="comment"># 把sample後的positive_roi分配給gt_box</span></div><div class="line">    positive_overlaps = tf.gather(overlaps, positive_indices)</div><div class="line">    <span class="comment"># 每個positive_rois對應gt_box overlaps最大值的下標[filter_n_proposals,1]</span></div><div class="line">    roi_gt_box_assignment = tf.argmax(positive_overlaps, axis=<span class="number">1</span>)</div><div class="line">    roi_gt_boxes = tf.gather(gt_boxes, roi_gt_box_assignment)</div><div class="line">    roi_gt_class_ids = tf.gather(gt_class_ids, roi_gt_box_assignment)</div><div class="line"></div><div class="line">    <span class="comment"># Compute bbox refinement for positive ROIs</span></div><div class="line">    deltas = utils.box_refinement_graph(positive_rois, roi_gt_boxes)</div><div class="line">    deltas /= config.BBOX_STD_DEV</div><div class="line"></div><div class="line">    <span class="comment"># Assign positive ROIs to GT masks</span></div><div class="line">    <span class="comment"># Permute masks to [N, height, width, 1]</span></div><div class="line">    transposed_masks = tf.expand_dims(tf.transpose(gt_masks, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]), <span class="number">-1</span>)</div><div class="line">    <span class="comment"># Pick the right mask for each ROI</span></div><div class="line">    roi_masks = tf.gather(transposed_masks, roi_gt_box_assignment)</div><div class="line"></div><div class="line">    <span class="comment"># Compute mask targets</span></div><div class="line">    boxes = positive_rois</div><div class="line">    <span class="keyword">if</span> config.USE_MINI_MASK:</div><div class="line">        <span class="comment"># Transform ROI corrdinates from normalized image space</span></div><div class="line">        <span class="comment"># to normalized mini-mask space.</span></div><div class="line">        y1, x1, y2, x2 = tf.split(positive_rois, <span class="number">4</span>, axis=<span class="number">1</span>)</div><div class="line">        gt_y1, gt_x1, gt_y2, gt_x2 = tf.split(roi_gt_boxes, <span class="number">4</span>, axis=<span class="number">1</span>)</div><div class="line">        gt_h = gt_y2 - gt_y1</div><div class="line">        gt_w = gt_x2 - gt_x1</div><div class="line">        y1 = (y1 - gt_y1) / gt_h</div><div class="line">        x1 = (x1 - gt_x1) / gt_w</div><div class="line">        y2 = (y2 - gt_y1) / gt_h</div><div class="line">        x2 = (x2 - gt_x1) / gt_w</div><div class="line">        boxes = tf.concat([y1, x1, y2, x2], <span class="number">1</span>)</div><div class="line">    box_ids = tf.range(<span class="number">0</span>, tf.shape(roi_masks)[<span class="number">0</span>])</div><div class="line">    masks = tf.image.crop_and_resize(tf.cast(roi_masks, tf.float32), boxes,</div><div class="line">                                     box_ids,</div><div class="line">                                     config.MASK_SHAPE)</div><div class="line">    <span class="comment"># Remove the extra dimension from masks.</span></div><div class="line">    masks = tf.squeeze(masks, axis=<span class="number">3</span>)</div><div class="line"></div><div class="line">    <span class="comment"># Threshold mask pixels at 0.5 to have GT masks be 0 or 1 to use with</span></div><div class="line">    <span class="comment"># binary cross entropy loss.</span></div><div class="line">    masks = tf.round(masks)</div><div class="line"></div><div class="line">    <span class="comment"># Append negative ROIs and pad bbox deltas and masks that</span></div><div class="line">    <span class="comment"># are not used for negative ROIs with zeros.</span></div><div class="line">    rois = tf.concat([positive_rois, negative_rois], axis=<span class="number">0</span>)</div><div class="line">    N = tf.shape(negative_rois)[<span class="number">0</span>]</div><div class="line">    P = tf.maximum(config.TRAIN_ROIS_PER_IMAGE - tf.shape(rois)[<span class="number">0</span>], <span class="number">0</span>)</div><div class="line">    rois = tf.pad(rois, [(<span class="number">0</span>, P), (<span class="number">0</span>, <span class="number">0</span>)])</div><div class="line">    roi_gt_boxes = tf.pad(roi_gt_boxes, [(<span class="number">0</span>, N + P), (<span class="number">0</span>, <span class="number">0</span>)])</div><div class="line">    roi_gt_class_ids = tf.pad(roi_gt_class_ids, [(<span class="number">0</span>, N + P)])</div><div class="line">    deltas = tf.pad(deltas, [(<span class="number">0</span>, N + P), (<span class="number">0</span>, <span class="number">0</span>)])</div><div class="line">    masks = tf.pad(masks, [[<span class="number">0</span>, N + P], (<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>)])</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rois, roi_gt_class_ids, deltas, masks</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/06/02/Mask-RCNN-Code-Reading-Propsal-Layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/02/Mask-RCNN-Code-Reading-Propsal-Layer/" itemprop="url">
                  Mask RCNNCode Reading for Proposal Layer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-02T23:57:33+08:00">
                2018-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通過下面這段程式碼拿到anchors以後</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Anchors</span></div><div class="line"><span class="keyword">if</span> mode == <span class="string">"training"</span>:</div><div class="line">  anchors = self.get_anchors(config.IMAGE_SHAPE)</div><div class="line">  <span class="comment"># Duplicate across the batch dimension because Keras requires it</span></div><div class="line">  <span class="comment"># <span class="doctag">TODO:</span> can this be optimized to avoid duplicating the anchors?</span></div><div class="line">  anchors = np.broadcast_to(anchors, (config.BATCH_SIZE,) + anchors.shape)</div><div class="line">  <span class="comment"># A hack to get around Keras's bad support for constants</span></div><div class="line">  anchors = KL.Lambda(<span class="keyword">lambda</span> x: tf.Variable(anchors), name=<span class="string">"anchors"</span>)(input_image)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">  anchors = input_anchors</div></pre></td></tr></table></figure>
<p>這裡總算要進行proposal layer計算了<br>將所有anchors還有相應對的分數跟偏移量當作輸入<br>而前面的東西都是class init的時候的設定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">rpn_class_logits, rpn_class, rpn_bbox = outputs</div><div class="line"></div><div class="line"><span class="comment"># Generate proposals</span></div><div class="line"><span class="comment"># Proposals are [batch, N, (y1, x1, y2, x2)] in normalized coordinates</span></div><div class="line"><span class="comment"># and zero padded.</span></div><div class="line"></div><div class="line"><span class="comment"># POST_NMS_ROIS_INFERENCE = 1000</span></div><div class="line"><span class="comment"># POST_NMS_ROIS_TRAINING = 2000</span></div><div class="line"></div><div class="line">    proposal_count = config.POST_NMS_ROIS_TRAINING <span class="keyword">if</span> mode == <span class="string">"training"</span>\</div><div class="line">            <span class="keyword">else</span> config.POST_NMS_ROIS_INFERENCE</div><div class="line">        </div><div class="line">rpn_rois = ProposalLayer(</div><div class="line">              proposal_count=proposal_count,</div><div class="line">              nms_threshold=config.RPN_NMS_THRESHOLD,</div><div class="line">              name=<span class="string">"ROI"</span>,</div><div class="line">              config=config)([rpn_class, rpn_bbox, anchors]</div><div class="line">              )</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> mode == <span class="string">"training"</span>:</div><div class="line">      <span class="comment"># Class ID mask to mark class IDs supported by the dataset the image</span></div><div class="line">      <span class="comment"># came from.</span></div><div class="line">      active_class_ids = KL.Lambda(</div><div class="line">          <span class="keyword">lambda</span> x: parse_image_meta_graph(x)[<span class="string">"active_class_ids"</span>]</div><div class="line">          )(input_image_meta)</div><div class="line">    </div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> config.USE_RPN_ROIS:</div><div class="line">          <span class="comment"># Ignore predicted ROIs and use ROIs provided as an input.</span></div><div class="line">          input_rois = KL.Input(shape=[config.POST_NMS_ROIS_TRAINING, <span class="number">4</span>],</div><div class="line">                                name=<span class="string">"input_roi"</span>, dtype=np.int32)</div><div class="line">          <span class="comment"># Normalize coordinates</span></div><div class="line">          target_rois = KL.Lambda(<span class="keyword">lambda</span> x: norm_boxes_graph(</div><div class="line">              x, K.shape(input_image)[<span class="number">1</span>:<span class="number">3</span>]))(input_rois)</div><div class="line">      <span class="keyword">else</span>:</div><div class="line">          target_rois = rpn_rois</div></pre></td></tr></table></figure>
<p>其中parse_image_meta_graph</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">"image_id"</span>: image_id,</div><div class="line">        <span class="string">"original_image_shape"</span>: original_image_shape,</div><div class="line">        <span class="string">"image_shape"</span>: image_shape,</div><div class="line">        <span class="string">"window"</span>: window,</div><div class="line">        <span class="string">"scale"</span>: scale,</div><div class="line">        <span class="string">"active_class_ids"</span>: active_class_ids,</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Proposal-Layer"><a href="#Proposal-Layer" class="headerlink" title="Proposal Layer"></a>Proposal Layer</h3><p>rpn_class：所有像素點BG/FG的機率值。<br>rpn_bbox：所有像素點對應anchor上的4個偏移值[dy, dx, log(dh), log(dw)]。<br>anchors:  剛剛通過預先生成的有序anchor列表，注意這裡有序表示feature_map上像素點生成的anchor以及該像素點生成的rpn_class和rpn_bbox是對應的（看paper看起來是這樣,但這樣理解對嗎, 有點不確定)<br>scores和deltas都是RPN中得到的</p>
<p>最終ProposalLayer會return一個經過bbox regression以及NMS過濾後anchor boxes set(稱為roi或proposal)，至此已經完成了RPN啦~<br>init內super的用法可參考 <a href="http://funhacks.net/explore-python/Class/super.html" target="_blank" rel="external">你不知道的 super
</a></p>
<p>要注意的事情是, 其實對於inference來說 這裡已經有RPN的結果了, 但對於training來說還少了一些東西, 就是跟grondtruth的比較還有等等, 所以才有後續的DetectionTargetLayer</p>
<p>另外Python中，如果在創建class的時候寫了call()， 那麼該class實例化出實例後， 實例名()就是調用call()。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProposalLayer</span><span class="params">(KE.Layer)</span>:</span></div><div class="line">    <span class="string">"""Receives anchor scores and selects a subset to pass as proposals</span></div><div class="line">    to the second stage. Filtering is done based on anchor scores and</div><div class="line">    non-max suppression to remove overlaps. It also applies bounding</div><div class="line">    box refinement deltas to anchors.</div><div class="line"></div><div class="line">    Inputs:</div><div class="line">        rpn_probs: [batch, anchors, (bg prob, fg prob)]</div><div class="line">        rpn_bbox: [batch, anchors, (dy, dx, log(dh), log(dw))]</div><div class="line">        anchors: [batch, (y1, x1, y2, x2)] anchors in normalized coordinates</div><div class="line"></div><div class="line">    Returns:</div><div class="line">        Proposals in normalized coordinates [batch, rois, (y1, x1, y2, x2)]</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, proposal_count, nms_threshold, config=None, **kwargs)</span>:</span></div><div class="line">        super(ProposalLayer, self).__init__(**kwargs)</div><div class="line">        self.config = config</div><div class="line">        self.proposal_count = proposal_count</div><div class="line">        self.nms_threshold = nms_threshold</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs)</span>:</span></div><div class="line">        <span class="comment">###實現了將傳入的anchors，及其scores、deltas進行topK的推薦和nms的推薦，最終輸出  </span></div><div class="line">        <span class="comment">###數量為proposal_counts的proposals。其中的scores和deltas都是RPN網絡中得到的</span></div><div class="line">        <span class="comment"># Box Scores. Use the foreground class confidence. [Batch, num_rois, 1]</span></div><div class="line">        scores = inputs[<span class="number">0</span>][:, :, <span class="number">1</span>]</div><div class="line">        <span class="comment"># Box deltas [batch, num_rois, 4]</span></div><div class="line">        deltas = inputs[<span class="number">1</span>]</div><div class="line">        deltas = deltas * np.reshape(self.config.RPN_BBOX_STD_DEV, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>])</div><div class="line">        <span class="comment"># Anchors</span></div><div class="line">        anchors = inputs[<span class="number">2</span>]</div><div class="line"></div><div class="line">        <span class="comment"># Improve performance by trimming to top anchors by score</span></div><div class="line">        <span class="comment"># and doing the rest on the smaller subset.</span></div><div class="line">        pre_nms_limit = tf.minimum(<span class="number">6000</span>, tf.shape(anchors)[<span class="number">1</span>])</div><div class="line">        ix = tf.nn.top_k(scores, pre_nms_limit, sorted=<span class="keyword">True</span>,</div><div class="line">                         name=<span class="string">"top_anchors"</span>).indices</div><div class="line">        scores = utils.batch_slice([scores, ix], <span class="keyword">lambda</span> x, y: tf.gather(x, y),</div><div class="line">                                   self.config.IMAGES_PER_GPU)</div><div class="line">        deltas = utils.batch_slice([deltas, ix], <span class="keyword">lambda</span> x, y: tf.gather(x, y),</div><div class="line">                                   self.config.IMAGES_PER_GPU)</div><div class="line">        pre_nms_anchors = utils.batch_slice([anchors, ix], <span class="keyword">lambda</span> a, x: tf.gather(a, x),</div><div class="line">                                    self.config.IMAGES_PER_GPU,</div><div class="line">                                    names=[<span class="string">"pre_nms_anchors"</span>])</div><div class="line"></div><div class="line">        <span class="comment"># Apply deltas to anchors to get refined anchors.</span></div><div class="line">        <span class="comment"># [batch, N, (y1, x1, y2, x2)]</span></div><div class="line">        <span class="comment">##利用deltas在anchors上，得到精煉後的boxs  </span></div><div class="line"></div><div class="line">        boxes = utils.batch_slice([pre_nms_anchors, deltas],</div><div class="line">                                  <span class="keyword">lambda</span> x, y: apply_box_deltas_graph(x, y),</div><div class="line">                                  self.config.IMAGES_PER_GPU,</div><div class="line">                                  names=[<span class="string">"refined_anchors"</span>])</div><div class="line">                                  </div><div class="line">        <span class="comment"># normalized coordinates就是對應原圖的百分比坐標</span></div><div class="line">        <span class="comment"># 下面的作用：防止修正後的anchor坐標超出了邊界即0&lt;=x,y&lt;=1</span></div><div class="line">        <span class="comment"># Clip to image boundaries. Since we're in normalized coordinates,</span></div><div class="line">        <span class="comment"># clip to 0..1 range. [batch, N, (y1, x1, y2, x2)]</span></div><div class="line">        window = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=np.float32)</div><div class="line">        boxes = utils.batch_slice(boxes,</div><div class="line">                                  <span class="keyword">lambda</span> x: clip_boxes_graph(x, window),</div><div class="line">                                  self.config.IMAGES_PER_GPU,</div><div class="line">                                  names=[<span class="string">"refined_anchors_clipped"</span>])</div><div class="line"></div><div class="line">        <span class="comment"># Filter out small boxes</span></div><div class="line">        <span class="comment"># According to Xinlei Chen's paper, this reduces detection accuracy</span></div><div class="line">        <span class="comment"># for small objects, so we're skipping it.</span></div><div class="line"></div><div class="line">        <span class="comment"># Non-max suppression</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nms</span><span class="params">(boxes, scores)</span>:</span></div><div class="line">            indices = tf.image.non_max_suppression(</div><div class="line">                boxes, scores, self.proposal_count,</div><div class="line">                self.nms_threshold, name=<span class="string">"rpn_non_max_suppression"</span>)</div><div class="line">            proposals = tf.gather(boxes, indices)</div><div class="line">            <span class="comment"># Pad if needed</span></div><div class="line">            padding = tf.maximum(self.proposal_count - tf.shape(proposals)[<span class="number">0</span>], <span class="number">0</span>)</div><div class="line">            <span class="comment">##利用deltas在anchors上，得到精化的boxs </span></div><div class="line">            proposals = tf.pad(proposals, [(<span class="number">0</span>, padding), (<span class="number">0</span>, <span class="number">0</span>)])</div><div class="line">            <span class="keyword">return</span> proposals</div><div class="line">             </div><div class="line"></div><div class="line">        proposals = utils.batch_slice([boxes, scores], nms,</div><div class="line">                                      self.config.IMAGES_PER_GPU)</div><div class="line">        <span class="keyword">return</span> proposals</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span><span class="params">(self, input_shape)</span>:</span></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">None</span>, self.proposal_count, <span class="number">4</span>)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/06/02/Mask-RCNN-Code-Reading-Anchor-boxes-Generate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/02/Mask-RCNN-Code-Reading-Anchor-boxes-Generate/" itemprop="url">
                  Mask RCNNCode Reading for Anchor boxes generate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-02T20:57:33+08:00">
                2018-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接續上面的RPN output</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">rpn_class_logits, rpn_class, rpn_bbox = outputs</div><div class="line"></div><div class="line"><span class="comment"># Generate proposals</span></div><div class="line"><span class="comment"># Proposals are [batch, N, (y1, x1, y2, x2)] in normalized coordinates</span></div><div class="line"><span class="comment"># and zero padded.</span></div><div class="line"></div><div class="line"><span class="comment"># POST_NMS_ROIS_INFERENCE = 1000</span></div><div class="line"><span class="comment"># POST_NMS_ROIS_TRAINING = 2000</span></div><div class="line"></div><div class="line">    proposal_count = config.POST_NMS_ROIS_TRAINING <span class="keyword">if</span> mode == <span class="string">"training"</span>\</div><div class="line">            <span class="keyword">else</span> config.POST_NMS_ROIS_INFERENCE</div><div class="line">        </div><div class="line">rpn_rois = ProposalLayer(</div><div class="line">              proposal_count=proposal_count,</div><div class="line">              nms_threshold=config.RPN_NMS_THRESHOLD,</div><div class="line">              name=<span class="string">"ROI"</span>,</div><div class="line">              config=config)([rpn_class, rpn_bbox, anchors]</div><div class="line">              )</div></pre></td></tr></table></figure>
<h1 id="Anchor-boxes-generate"><a href="#Anchor-boxes-generate" class="headerlink" title="Anchor boxes generate"></a>Anchor boxes generate</h1><p>而 anchors 的來源呢<br>在主程式碼中有這段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Anchors</span></div><div class="line"><span class="keyword">if</span> mode == <span class="string">"training"</span>:</div><div class="line">  anchors = self.get_anchors(config.IMAGE_SHAPE)</div><div class="line">  <span class="comment"># Duplicate across the batch dimension because Keras requires it</span></div><div class="line">  <span class="comment"># <span class="doctag">TODO:</span> can this be optimized to avoid duplicating the anchors?</span></div><div class="line">  anchors = np.broadcast_to(anchors, (config.BATCH_SIZE,) + anchors.shape)</div><div class="line">  <span class="comment"># A hack to get around Keras's bad support for constants</span></div><div class="line">  anchors = KL.Lambda(<span class="keyword">lambda</span> x: tf.Variable(anchors), name=<span class="string">"anchors"</span>)(input_image)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">  anchors = input_anchors</div></pre></td></tr></table></figure>
<h3 id="def-get-anchors"><a href="#def-get-anchors" class="headerlink" title="def get_anchors"></a>def get_anchors</h3><p>compute_backbone_shapes:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Computes <span class="keyword">the</span> width <span class="keyword">and</span> height <span class="keyword">of</span> <span class="keyword">each</span> stage <span class="keyword">of</span> <span class="keyword">the</span> backbone network.</div><div class="line">Returns:</div><div class="line">  [N, (height, width)]. Where N is <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> stages</div></pre></td></tr></table></figure>
<p>utils.generate_pyramid_anchors這邊看起來相對於single scale的backbone, 這裡多了backbone_shapes這項變數, 是因為需要知道該層feature_map大小才能回推anchor boxes</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">RPN_ANCHOR_SCALES = (<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>)</div><div class="line">RPN_ANCHOR_RATIOS = [<span class="number">0.5</span>, <span class="number">1</span> ,<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_anchors</span><span class="params">(self, image_shape)</span>:</span></div><div class="line">   <span class="string">"""Returns anchor pyramid for the given image size."""</span></div><div class="line">   backbone_shapes = compute_backbone_shapes(self.config, image_shape)</div><div class="line">   <span class="comment"># Cache anchors and reuse if image shape is the same</span></div><div class="line">   <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">"_anchor_cache"</span>):</div><div class="line">       self._anchor_cache = &#123;&#125;</div><div class="line">   <span class="keyword">if</span> <span class="keyword">not</span> tuple(image_shape) <span class="keyword">in</span> self._anchor_cache:</div><div class="line">       <span class="comment"># Generate Anchors</span></div><div class="line">       a = utils.generate_pyramid_anchors(</div><div class="line">           self.config.RPN_ANCHOR_SCALES,</div><div class="line">           self.config.RPN_ANCHOR_RATIOS,</div><div class="line">           backbone_shapes,</div><div class="line">           self.config.BACKBONE_STRIDES,</div><div class="line">           self.config.RPN_ANCHOR_STRIDE)</div><div class="line">       <span class="comment"># Keep a copy of the latest anchors in pixel coordinates because</span></div><div class="line">       <span class="comment"># it's used in inspect_model notebooks.</span></div><div class="line">       <span class="comment"># <span class="doctag">TODO:</span> Remove this after the notebook are refactored to not use it</span></div><div class="line">       self.anchors = a</div><div class="line">       <span class="comment"># Normalize coordinates</span></div><div class="line">       self._anchor_cache[tuple(image_shape)] = utils.norm_boxes(a, image_shape[:<span class="number">2</span>])</div><div class="line">   <span class="keyword">return</span> self._anchor_cache[tuple(image_shape)]</div></pre></td></tr></table></figure>
<h3 id="utils-generate-pyramid-anchors"><a href="#utils-generate-pyramid-anchors" class="headerlink" title="utils.generate_pyramid_anchors"></a>utils.generate_pyramid_anchors</h3><p>這邊很明顯就是包裝一層, 讓各個stage (P2~P6)的各自去計算以後append<br>後方操作…舉個例子, 順便了解一下IO, 其實只是會了整形而已</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a=np.arange(<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b=np.array([<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">array([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.append(a)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">[array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.append(b)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">[array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]), array([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.concatenate(c,axis=<span class="number">0</span>)</div><div class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_pyramid_anchors</span><span class="params">(scales, ratios, feature_shapes, feature_strides,anchor_stride)</span>:</span></div><div class="line">    <span class="string">"""Generate anchors at different levels of a feature pyramid. Each scale</span></div><div class="line">    is associated with a level of the pyramid, but each ratio is used in</div><div class="line">    all levels of the pyramid.</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    anchors: [N, (y1, x1, y2, x2)]. All generated anchors in one array. Sorted</div><div class="line">        with the same order of the given scales. So, anchors of scale[0] come</div><div class="line">        first, then anchors of scale[1], and so on.</div><div class="line">    """</div><div class="line">    <span class="comment"># Anchors</span></div><div class="line">    <span class="comment"># [anchor_count, (y1, x1, y2, x2)]</span></div><div class="line">    anchors = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(scales)):</div><div class="line">        anchors.append(</div><div class="line">            generate_anchors(</div><div class="line">                    scales[i],  <span class="comment"># self.config.RPN_ANCHOR_SCALES</span></div><div class="line">                    ratios,     <span class="comment"># self.config.RPN_ANCHOR_RATIOS</span></div><div class="line">                    feature_shapes[i],  <span class="comment"># backbone_shapes</span></div><div class="line">                    feature_strides[i], <span class="comment"># self.config.BACKBONE_STRIDES [4, 8, 16, 32, 64]</span></div><div class="line">                    anchor_stride       <span class="comment"># self.config.RPN_ANCHOR_STRIDE</span></div><div class="line">            ))</div><div class="line">    <span class="keyword">return</span> np.concatenate(anchors, axis=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h3 id="utils-generate-anchors"><a href="#utils-generate-anchors" class="headerlink" title="utils.generate_anchors"></a>utils.generate_anchors</h3><p>Code內其實有參數說明了<br>scales就是anchor boxes邊長了<br>ratio就是anchor boxes的比例<br>shapes是原圖<br>feature_stride 其實就是原圖與該feature層(例如p3)的縮放倍率, 如果是resnet或是VGG這種就一律都是縮放16倍了<br>anchor_stride 這通常是1吧XD 就是以縮放比切割原圖後可以得到(w/feature_stride)x(h/feature_stride)個grid, 那在此多少區間弄一個anchor?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_anchors</span><span class="params">(scales, ratios, shape, feature_stride, anchor_stride)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    scales: 1D array of anchor sizes in pixels. Example: [32, 64, 128]</div><div class="line">    ratios: 1D array of anchor ratios of width/height. Example: [0.5, 1, 2]</div><div class="line">    shape: [height, width] spatial shape of the feature map over which</div><div class="line">            to generate anchors.</div><div class="line">    feature_stride: Stride of the feature map relative to the image in pixels.</div><div class="line">    anchor_stride: Stride of anchors on the feature map. For example, if the</div><div class="line">        value is 2 then generate anchors for every other feature map pixel.</div><div class="line">    """</div><div class="line">    <span class="comment"># Get all combinations of scales and ratios</span></div><div class="line">    scales, ratios = np.meshgrid(np.array(scales), np.array(ratios))</div><div class="line">    scales = scales.flatten()</div><div class="line">    ratios = ratios.flatten()</div><div class="line"></div><div class="line">    <span class="comment"># Enumerate heights and widths from scales and ratios</span></div><div class="line">    heights = scales / np.sqrt(ratios)</div><div class="line">    widths = scales * np.sqrt(ratios)</div><div class="line"></div><div class="line">    <span class="comment"># Enumerate shifts in feature space</span></div><div class="line">    shifts_y = np.arange(<span class="number">0</span>, shape[<span class="number">0</span>], anchor_stride) * feature_stride</div><div class="line">    shifts_x = np.arange(<span class="number">0</span>, shape[<span class="number">1</span>], anchor_stride) * feature_stride</div><div class="line">    shifts_x, shifts_y = np.meshgrid(shifts_x, shifts_y)</div><div class="line"></div><div class="line">    <span class="comment"># Enumerate combinations of shifts, widths, and heights</span></div><div class="line">    box_widths, box_centers_x = np.meshgrid(widths, shifts_x)</div><div class="line">    box_heights, box_centers_y = np.meshgrid(heights, shifts_y)</div><div class="line"></div><div class="line">    <span class="comment"># Reshape to get a list of (y, x) and a list of (h, w)</span></div><div class="line">    box_centers = np.stack(</div><div class="line">        [box_centers_y, box_centers_x], axis=<span class="number">2</span>).reshape([<span class="number">-1</span>, <span class="number">2</span>])</div><div class="line">    box_sizes = np.stack([box_heights, box_widths], axis=<span class="number">2</span>).reshape([<span class="number">-1</span>, <span class="number">2</span>])</div><div class="line"></div><div class="line">    <span class="comment"># Convert to corner coordinates (y1, x1, y2, x2)</span></div><div class="line">    boxes = np.concatenate([box_centers - <span class="number">0.5</span> * box_sizes,</div><div class="line">                            box_centers + <span class="number">0.5</span> * box_sizes], axis=<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> boxes</div></pre></td></tr></table></figure>
<p>下面用一組參數示範一下, 到最後widths, heights 就可以得到anchor boxes的所有邊長了<br>np.meshgrid的部分, 要注意傳入參數得需要是一維的, 接著再用flatten()把它變成1xN的array<br>np.stack我覺得挺難理解, 可以看這邊 <a href="https://blog.csdn.net/qq_17550379/article/details/78934529" target="_blank" rel="external">numpy.stack最通俗的理解</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Get all combinations of scales and ratios</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>scales = [<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ratios = [<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.meshgrid(np.array(scales), np.array(ratios))</div><div class="line">[</div><div class="line">    array([</div><div class="line">        [ <span class="number">32</span>,  <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>],</div><div class="line">        [ <span class="number">32</span>,  <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>],</div><div class="line">        [ <span class="number">32</span>,  <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>]</div><div class="line">    ]), </div><div class="line">    array([</div><div class="line">        [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>],</div><div class="line">        [<span class="number">1.</span> , <span class="number">1.</span> , <span class="number">1.</span> , <span class="number">1.</span> , <span class="number">1.</span> ],</div><div class="line">        [<span class="number">2.</span> , <span class="number">2.</span> , <span class="number">2.</span> , <span class="number">2.</span> , <span class="number">2.</span> ]</div><div class="line">    ])</div><div class="line">]</div><div class="line"></div><div class="line"><span class="comment">### 反過來傳結果有點不一樣</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.meshgrid(np.array(ratios), np.array(scales))</div><div class="line">[array([[<span class="number">0.5</span>, <span class="number">1.</span> , <span class="number">2.</span> ],</div><div class="line">       [<span class="number">0.5</span>, <span class="number">1.</span> , <span class="number">2.</span> ],</div><div class="line">       [<span class="number">0.5</span>, <span class="number">1.</span> , <span class="number">2.</span> ],</div><div class="line">       [<span class="number">0.5</span>, <span class="number">1.</span> , <span class="number">2.</span> ],</div><div class="line">       [<span class="number">0.5</span>, <span class="number">1.</span> , <span class="number">2.</span> ]]), </div><div class="line">       </div><div class="line"> array([[ <span class="number">32</span>,  <span class="number">32</span>,  <span class="number">32</span>],</div><div class="line">       [ <span class="number">64</span>,  <span class="number">64</span>,  <span class="number">64</span>],</div><div class="line">       [<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>],</div><div class="line">       [<span class="number">256</span>, <span class="number">256</span>, <span class="number">256</span>],</div><div class="line">       [<span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>]])]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>scales = scales.flatten()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ratios = ratios.flatten()</div><div class="line"></div><div class="line"><span class="comment"># Enumerate heights and widths from scales and ratios       </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heights = scales / np.sqrt(ratios)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>widths = scales * np.sqrt(ratios)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heights</div><div class="line">array([ <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, <span class="number">181.01933598</span>, <span class="number">362.03867197</span>,</div><div class="line">       <span class="number">724.07734394</span>,  <span class="number">32.</span>        ,  <span class="number">64.</span>        , <span class="number">128.</span>        ,</div><div class="line">       <span class="number">256.</span>        , <span class="number">512.</span>        ,  <span class="number">22.627417</span>  ,  <span class="number">45.254834</span>  ,</div><div class="line">        <span class="number">90.50966799</span>, <span class="number">181.01933598</span>, <span class="number">362.03867197</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>widths</div><div class="line">array([ <span class="number">22.627417</span>  ,  <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, <span class="number">181.01933598</span>,</div><div class="line">       <span class="number">362.03867197</span>,  <span class="number">32.</span>        ,  <span class="number">64.</span>        , <span class="number">128.</span>        ,</div><div class="line">       <span class="number">256.</span>        , <span class="number">512.</span>        ,  <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>,</div><div class="line">       <span class="number">181.01933598</span>, <span class="number">362.03867197</span>, <span class="number">724.07734394</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heights.shape, widths.shape</div><div class="line">((<span class="number">15</span>,), (<span class="number">15</span>,))</div><div class="line"></div><div class="line"><span class="comment"># Enumerate shifts in feature space</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>anchor_stride=<span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shape=[<span class="number">1024</span>,<span class="number">2048</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>feature_strides = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>feature_stride = feature_strides[<span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shifts_x = np.arange(<span class="number">0</span>, shape[<span class="number">1</span>], anchor_stride) * feature_stride</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shifts_y = np.arange(<span class="number">0</span>, shape[<span class="number">0</span>], anchor_stride) * feature_stride</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shifts_x</div><div class="line">array([    <span class="number">0</span>,    <span class="number">16</span>,    <span class="number">32</span>, ..., <span class="number">32720</span>, <span class="number">32736</span>, <span class="number">32752</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shifts_y</div><div class="line">array([    <span class="number">0</span>,    <span class="number">16</span>,    <span class="number">32</span>, ..., <span class="number">16336</span>, <span class="number">16352</span>, <span class="number">16368</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(shifts_x), len(shifts_y)</div><div class="line"><span class="number">2048</span>,<span class="number">1024</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shifts_x, shifts_y = np.meshgrid(shifts_x, shifts_y)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shifts_y</div><div class="line">array([[    <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>, ...,     <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>],</div><div class="line">       [   <span class="number">16</span>,    <span class="number">16</span>,    <span class="number">16</span>, ...,    <span class="number">16</span>,    <span class="number">16</span>,    <span class="number">16</span>],</div><div class="line">       [   <span class="number">32</span>,    <span class="number">32</span>,    <span class="number">32</span>, ...,    <span class="number">32</span>,    <span class="number">32</span>,    <span class="number">32</span>],</div><div class="line">       ...,</div><div class="line">       [<span class="number">16336</span>, <span class="number">16336</span>, <span class="number">16336</span>, ..., <span class="number">16336</span>, <span class="number">16336</span>, <span class="number">16336</span>],</div><div class="line">       [<span class="number">16352</span>, <span class="number">16352</span>, <span class="number">16352</span>, ..., <span class="number">16352</span>, <span class="number">16352</span>, <span class="number">16352</span>],</div><div class="line">       [<span class="number">16368</span>, <span class="number">16368</span>, <span class="number">16368</span>, ..., <span class="number">16368</span>, <span class="number">16368</span>, <span class="number">16368</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shifts_x</div><div class="line">array([[    <span class="number">0</span>,    <span class="number">16</span>,    <span class="number">32</span>, ..., <span class="number">32720</span>, <span class="number">32736</span>, <span class="number">32752</span>],</div><div class="line">       [    <span class="number">0</span>,    <span class="number">16</span>,    <span class="number">32</span>, ..., <span class="number">32720</span>, <span class="number">32736</span>, <span class="number">32752</span>],</div><div class="line">       [    <span class="number">0</span>,    <span class="number">16</span>,    <span class="number">32</span>, ..., <span class="number">32720</span>, <span class="number">32736</span>, <span class="number">32752</span>],</div><div class="line">       ...,</div><div class="line">       [    <span class="number">0</span>,    <span class="number">16</span>,    <span class="number">32</span>, ..., <span class="number">32720</span>, <span class="number">32736</span>, <span class="number">32752</span>],</div><div class="line">       [    <span class="number">0</span>,    <span class="number">16</span>,    <span class="number">32</span>, ..., <span class="number">32720</span>, <span class="number">32736</span>, <span class="number">32752</span>],</div><div class="line">       [    <span class="number">0</span>,    <span class="number">16</span>,    <span class="number">32</span>, ..., <span class="number">32720</span>, <span class="number">32736</span>, <span class="number">32752</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shifts_x.shape, shifts_y.shape</div><div class="line">((<span class="number">1024</span>, <span class="number">2048</span>), (<span class="number">1024</span>, <span class="number">2048</span>))</div><div class="line">       </div><div class="line"><span class="comment"># Enumerate combinations of shifts, widths, and heights</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>box_widths, box_centers_x = np.meshgrid(widths, shifts_x)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>box_heights, box_centers_y = np.meshgrid(heights, shifts_y)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>box_heights</div><div class="line">array([[ <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, <span class="number">181.01933598</span>, ...,  <span class="number">90.50966799</span>,</div><div class="line">        <span class="number">181.01933598</span>, <span class="number">362.03867197</span>],</div><div class="line">       [ <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, <span class="number">181.01933598</span>, ...,  <span class="number">90.50966799</span>,</div><div class="line">        <span class="number">181.01933598</span>, <span class="number">362.03867197</span>],</div><div class="line">       [ <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, <span class="number">181.01933598</span>, ...,  <span class="number">90.50966799</span>,</div><div class="line">        <span class="number">181.01933598</span>, <span class="number">362.03867197</span>],</div><div class="line">       ...,</div><div class="line">       [ <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, <span class="number">181.01933598</span>, ...,  <span class="number">90.50966799</span>,</div><div class="line">        <span class="number">181.01933598</span>, <span class="number">362.03867197</span>],</div><div class="line">       [ <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, <span class="number">181.01933598</span>, ...,  <span class="number">90.50966799</span>,</div><div class="line">        <span class="number">181.01933598</span>, <span class="number">362.03867197</span>],</div><div class="line">       [ <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, <span class="number">181.01933598</span>, ...,  <span class="number">90.50966799</span>,</div><div class="line">        <span class="number">181.01933598</span>, <span class="number">362.03867197</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>box_centers_y</div><div class="line">array([[    <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>, ...,     <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>],</div><div class="line">       [    <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>, ...,     <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>],</div><div class="line">       [    <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>, ...,     <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>],</div><div class="line">       ...,</div><div class="line">       [<span class="number">16368</span>, <span class="number">16368</span>, <span class="number">16368</span>, ..., <span class="number">16368</span>, <span class="number">16368</span>, <span class="number">16368</span>],</div><div class="line">       [<span class="number">16368</span>, <span class="number">16368</span>, <span class="number">16368</span>, ..., <span class="number">16368</span>, <span class="number">16368</span>, <span class="number">16368</span>],</div><div class="line">       [<span class="number">16368</span>, <span class="number">16368</span>, <span class="number">16368</span>, ..., <span class="number">16368</span>, <span class="number">16368</span>, <span class="number">16368</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>box_centers_x</div><div class="line">array([[    <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>, ...,     <span class="number">0</span>,     <span class="number">0</span>,     <span class="number">0</span>],</div><div class="line">       [   <span class="number">16</span>,    <span class="number">16</span>,    <span class="number">16</span>, ...,    <span class="number">16</span>,    <span class="number">16</span>,    <span class="number">16</span>],</div><div class="line">       [   <span class="number">32</span>,    <span class="number">32</span>,    <span class="number">32</span>, ...,    <span class="number">32</span>,    <span class="number">32</span>,    <span class="number">32</span>],</div><div class="line">       ...,</div><div class="line">       [<span class="number">32720</span>, <span class="number">32720</span>, <span class="number">32720</span>, ..., <span class="number">32720</span>, <span class="number">32720</span>, <span class="number">32720</span>],</div><div class="line">       [<span class="number">32736</span>, <span class="number">32736</span>, <span class="number">32736</span>, ..., <span class="number">32736</span>, <span class="number">32736</span>, <span class="number">32736</span>],</div><div class="line">       [<span class="number">32752</span>, <span class="number">32752</span>, <span class="number">32752</span>, ..., <span class="number">32752</span>, <span class="number">32752</span>, <span class="number">32752</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>box_widths</div><div class="line">array([[ <span class="number">22.627417</span>  ,  <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, ..., <span class="number">181.01933598</span>,</div><div class="line">        <span class="number">362.03867197</span>, <span class="number">724.07734394</span>],</div><div class="line">       [ <span class="number">22.627417</span>  ,  <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, ..., <span class="number">181.01933598</span>,</div><div class="line">        <span class="number">362.03867197</span>, <span class="number">724.07734394</span>],</div><div class="line">       [ <span class="number">22.627417</span>  ,  <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, ..., <span class="number">181.01933598</span>,</div><div class="line">        <span class="number">362.03867197</span>, <span class="number">724.07734394</span>],</div><div class="line">       ...,</div><div class="line">       [ <span class="number">22.627417</span>  ,  <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, ..., <span class="number">181.01933598</span>,</div><div class="line">        <span class="number">362.03867197</span>, <span class="number">724.07734394</span>],</div><div class="line">       [ <span class="number">22.627417</span>  ,  <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, ..., <span class="number">181.01933598</span>,</div><div class="line">        <span class="number">362.03867197</span>, <span class="number">724.07734394</span>],</div><div class="line">       [ <span class="number">22.627417</span>  ,  <span class="number">45.254834</span>  ,  <span class="number">90.50966799</span>, ..., <span class="number">181.01933598</span>,</div><div class="line">        <span class="number">362.03867197</span>, <span class="number">724.07734394</span>]])</div><div class="line"></div><div class="line"><span class="number">3867197</span>,&gt;&gt;&gt; box_widths.shape, box_centers_x.shape, box_heights.shape , box_centers_y.shape</div><div class="line">((<span class="number">2097152</span>, <span class="number">15</span>), (<span class="number">2097152</span>, <span class="number">15</span>), (<span class="number">2097152</span>, <span class="number">15</span>), (<span class="number">2097152</span>, <span class="number">15</span>))</div><div class="line"></div><div class="line"><span class="comment"># Reshape to get a list of (y, x) and a list of (h, w)</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>box_centers</div><div class="line">array([[    <span class="number">0</span>,     <span class="number">0</span>],</div><div class="line">       [    <span class="number">0</span>,     <span class="number">0</span>],</div><div class="line">       [    <span class="number">0</span>,     <span class="number">0</span>],</div><div class="line">       ...,</div><div class="line">       [<span class="number">16368</span>, <span class="number">32752</span>],</div><div class="line">       [<span class="number">16368</span>, <span class="number">32752</span>],</div><div class="line">       [<span class="number">16368</span>, <span class="number">32752</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>box_sizes</div><div class="line">array([[ <span class="number">45.254834</span>  ,  <span class="number">22.627417</span>  ],</div><div class="line">       [ <span class="number">90.50966799</span>,  <span class="number">45.254834</span>  ],</div><div class="line">       [<span class="number">181.01933598</span>,  <span class="number">90.50966799</span>],</div><div class="line">       ...,</div><div class="line">       [ <span class="number">90.50966799</span>, <span class="number">181.01933598</span>],</div><div class="line">       [<span class="number">181.01933598</span>, <span class="number">362.03867197</span>],</div><div class="line">       [<span class="number">362.03867197</span>, <span class="number">724.07734394</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(box_centers),len(box_sizes)</div><div class="line">(<span class="number">31457280</span>, <span class="number">31457280</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>box_centers.shape, box_sizes.shape</div><div class="line">((<span class="number">31457280</span>, <span class="number">2</span>), (<span class="number">31457280</span>, <span class="number">2</span>))</div><div class="line"></div><div class="line"><span class="comment"># Convert to corner coordinates (y1, x1, y2, x2)</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>boxes = np.concatenate([box_centers - <span class="number">0.5</span> * box_sizes,</div><div class="line"><span class="meta">... </span>                            box_centers + <span class="number">0.5</span> * box_sizes], axis=<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>boxes</div><div class="line">array([[<span class="number">-2.26274170e+01</span>, <span class="number">-1.13137085e+01</span>,  <span class="number">2.26274170e+01</span>,</div><div class="line">         <span class="number">1.13137085e+01</span>],</div><div class="line">       [<span class="number">-4.52548340e+01</span>, <span class="number">-2.26274170e+01</span>,  <span class="number">4.52548340e+01</span>,</div><div class="line">         <span class="number">2.26274170e+01</span>],</div><div class="line">       [<span class="number">-9.05096680e+01</span>, <span class="number">-4.52548340e+01</span>,  <span class="number">9.05096680e+01</span>,</div><div class="line">         <span class="number">4.52548340e+01</span>],</div><div class="line">       ...,</div><div class="line">       [ <span class="number">1.63227452e+04</span>,  <span class="number">3.26614903e+04</span>,  <span class="number">1.64132548e+04</span>,</div><div class="line">         <span class="number">3.28425097e+04</span>],</div><div class="line">       [ <span class="number">1.62774903e+04</span>,  <span class="number">3.25709807e+04</span>,  <span class="number">1.64585097e+04</span>,</div><div class="line">         <span class="number">3.29330193e+04</span>],</div><div class="line">       [ <span class="number">1.61869807e+04</span>,  <span class="number">3.23899613e+04</span>,  <span class="number">1.65490193e+04</span>,</div><div class="line">         <span class="number">3.31140387e+04</span>]])</div><div class="line">         </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>boxes.shape</div><div class="line">(<span class="number">31457280</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.broadcast_to(boxes, (<span class="number">4</span>,) + boxes.shape)</div><div class="line">array([[[<span class="number">-2.26274170e+01</span>, <span class="number">-1.13137085e+01</span>,  <span class="number">2.26274170e+01</span>,</div><div class="line">          <span class="number">1.13137085e+01</span>],</div><div class="line">        [<span class="number">-4.52548340e+01</span>, <span class="number">-2.26274170e+01</span>,  <span class="number">4.52548340e+01</span>,</div><div class="line">          <span class="number">2.26274170e+01</span>],</div><div class="line">        [<span class="number">-9.05096680e+01</span>, <span class="number">-4.52548340e+01</span>,  <span class="number">9.05096680e+01</span>,</div><div class="line">          <span class="number">4.52548340e+01</span>],</div><div class="line">        ...,</div><div class="line">        [ <span class="number">1.63227452e+04</span>,  <span class="number">3.26614903e+04</span>,  <span class="number">1.64132548e+04</span>,</div><div class="line">          <span class="number">3.28425097e+04</span>],</div><div class="line">        [ <span class="number">1.62774903e+04</span>,  <span class="number">3.25709807e+04</span>,  <span class="number">1.64585097e+04</span>,</div><div class="line">          <span class="number">3.29330193e+04</span>],</div><div class="line">        [ <span class="number">1.61869807e+04</span>,  <span class="number">3.23899613e+04</span>,  <span class="number">1.65490193e+04</span>,</div><div class="line">          <span class="number">3.31140387e+04</span>]],</div><div class="line"></div><div class="line">       [[<span class="number">-2.26274170e+01</span>, <span class="number">-1.13137085e+01</span>,  <span class="number">2.26274170e+01</span>,</div><div class="line">          <span class="number">1.13137085e+01</span>],</div><div class="line">        [<span class="number">-4.52548340e+01</span>, <span class="number">-2.26274170e+01</span>,  <span class="number">4.52548340e+01</span>,</div><div class="line">          <span class="number">2.26274170e+01</span>],</div><div class="line">        [<span class="number">-9.05096680e+01</span>, <span class="number">-4.52548340e+01</span>,  <span class="number">9.05096680e+01</span>,</div><div class="line">          <span class="number">4.52548340e+01</span>],</div><div class="line">        ...,</div><div class="line">        [ <span class="number">1.63227452e+04</span>,  <span class="number">3.26614903e+04</span>,  <span class="number">1.64132548e+04</span>,</div><div class="line">          <span class="number">3.28425097e+04</span>],</div><div class="line">        [ <span class="number">1.62774903e+04</span>,  <span class="number">3.25709807e+04</span>,  <span class="number">1.64585097e+04</span>,</div><div class="line">          <span class="number">3.29330193e+04</span>],</div><div class="line">        [ <span class="number">1.61869807e+04</span>,  <span class="number">3.23899613e+04</span>,  <span class="number">1.65490193e+04</span>,</div><div class="line">          <span class="number">3.31140387e+04</span>]],</div><div class="line"></div><div class="line">       [[<span class="number">-2.26274170e+01</span>, <span class="number">-1.13137085e+01</span>,  <span class="number">2.26274170e+01</span>,</div><div class="line">          <span class="number">1.13137085e+01</span>],</div><div class="line">        [<span class="number">-4.52548340e+01</span>, <span class="number">-2.26274170e+01</span>,  <span class="number">4.52548340e+01</span>,</div><div class="line">          <span class="number">2.26274170e+01</span>],</div><div class="line">        [<span class="number">-9.05096680e+01</span>, <span class="number">-4.52548340e+01</span>,  <span class="number">9.05096680e+01</span>,</div><div class="line">          <span class="number">4.52548340e+01</span>],</div><div class="line">        ...,</div><div class="line">        [ <span class="number">1.63227452e+04</span>,  <span class="number">3.26614903e+04</span>,  <span class="number">1.64132548e+04</span>,</div><div class="line">          <span class="number">3.28425097e+04</span>],</div><div class="line">        [ <span class="number">1.62774903e+04</span>,  <span class="number">3.25709807e+04</span>,  <span class="number">1.64585097e+04</span>,</div><div class="line">          <span class="number">3.29330193e+04</span>],</div><div class="line">        [ <span class="number">1.61869807e+04</span>,  <span class="number">3.23899613e+04</span>,  <span class="number">1.65490193e+04</span>,</div><div class="line">          <span class="number">3.31140387e+04</span>]],</div><div class="line"></div><div class="line">       [[<span class="number">-2.26274170e+01</span>, <span class="number">-1.13137085e+01</span>,  <span class="number">2.26274170e+01</span>,</div><div class="line">          <span class="number">1.13137085e+01</span>],</div><div class="line">        [<span class="number">-4.52548340e+01</span>, <span class="number">-2.26274170e+01</span>,  <span class="number">4.52548340e+01</span>,</div><div class="line">          <span class="number">2.26274170e+01</span>],</div><div class="line">        [<span class="number">-9.05096680e+01</span>, <span class="number">-4.52548340e+01</span>,  <span class="number">9.05096680e+01</span>,</div><div class="line">          <span class="number">4.52548340e+01</span>],</div><div class="line">        ...,</div><div class="line">        [ <span class="number">1.63227452e+04</span>,  <span class="number">3.26614903e+04</span>,  <span class="number">1.64132548e+04</span>,</div><div class="line">          <span class="number">3.28425097e+04</span>],</div><div class="line">        [ <span class="number">1.62774903e+04</span>,  <span class="number">3.25709807e+04</span>,  <span class="number">1.64585097e+04</span>,</div><div class="line">          <span class="number">3.29330193e+04</span>],</div><div class="line">        [ <span class="number">1.61869807e+04</span>,  <span class="number">3.23899613e+04</span>,  <span class="number">1.65490193e+04</span>,</div><div class="line">          <span class="number">3.31140387e+04</span>]]])</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.broadcast_to(boxes, (<span class="number">4</span>,) + boxes.shape).shape</div><div class="line">(<span class="number">4</span>, <span class="number">31457280</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/05/30/Mask-RCNN-Code-Reading-RPN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/30/Mask-RCNN-Code-Reading-RPN/" itemprop="url">
                  Mask RCNN Code Reading for RPN
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-30T09:16:43+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Mask_RCNN V2.1版本</p>
<p>檔案：<a href="https://github.com/matterport/Mask_RCNN/blob/master/mrcnn/model.py#L822" target="_blank" rel="external">Model.py</a></p>
<p><img src="/media/15276733083036.jpg" alt=""></p>
<h3 id="Class-MaskRCNN"><a href="#Class-MaskRCNN" class="headerlink" title="Class MaskRCNN():"></a>Class MaskRCNN():</h3><p>這部分是在程式碼主體所使用到RPN的部分, 其中傳入參數預設為此, for loop那邊可以看到有幾個從fpn的output就會有幾個rpn</p>
<pre><code>RPN_ANCHOR_RATIOS = [0.5, 1, 2]
RPN_ANCHOR_STRIDE = 1
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Note that P6 is used in RPN, but not in the classifier heads.</span></div><div class="line">       rpn_feature_maps = [P2, P3, P4, P5, P6]</div><div class="line">       mrcnn_feature_maps = [P2, P3, P4, P5]</div><div class="line"></div><div class="line">       <span class="comment"># Anchors</span></div><div class="line">       <span class="keyword">if</span> mode == <span class="string">"training"</span>:</div><div class="line">           anchors = self.get_anchors(config.IMAGE_SHAPE)</div><div class="line">           <span class="comment"># Duplicate across the batch dimension because Keras requires it</span></div><div class="line">           <span class="comment"># <span class="doctag">TODO:</span> can this be optimized to avoid duplicating the anchors?</span></div><div class="line">           anchors = np.broadcast_to(anchors, (config.BATCH_SIZE,) + anchors.shape)</div><div class="line">           <span class="comment"># A hack to get around Keras's bad support for constants</span></div><div class="line">           anchors = KL.Lambda(<span class="keyword">lambda</span> x: tf.Variable(anchors), name=<span class="string">"anchors"</span>)(input_image)</div><div class="line">       <span class="keyword">else</span>:</div><div class="line">           anchors = input_anchors</div><div class="line"></div><div class="line">       <span class="comment"># RPN Model</span></div><div class="line">       rpn = build_rpn_model(config.RPN_ANCHOR_STRIDE,</div><div class="line">                             len(config.RPN_ANCHOR_RATIOS), <span class="number">256</span>)</div></pre></td></tr></table></figure>
<p>其中layer_output會長這樣, 就是一堆input是rpn_feature_maps = [P2, P3, P4, P5, P6] 輸出是[“rpn_class_logits”, “rpn_class”, “rpn_bbox”]的東西</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[&lt;tf.Tensor 'rpn_model/lambda_2/Reshape:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model/rpn_class_xxx/truediv:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model/lambda_3/Reshape:0' shape=(?, ?, 4) dtype=float32&gt;], [&lt;tf.Tensor 'rpn_model_1/lambda_2/Reshape:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model_1/rpn_class_xxx/truediv:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model_1/lambda_3/Reshape:0' shape=(?, ?, 4) dtype=float32&gt;], [&lt;tf.Tensor 'rpn_model_2/lambda_2/Reshape:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model_2/rpn_class_xxx/truediv:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model_2/lambda_3/Reshape:0' shape=(?, ?, 4) dtype=float32&gt;], [&lt;tf.Tensor 'rpn_model_3/lambda_2/Reshape:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model_3/rpn_class_xxx/truediv:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model_3/lambda_3/Reshape:0' shape=(?, ?, 4) dtype=float32&gt;], [&lt;tf.Tensor 'rpn_model_4/lambda_2/Reshape:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model_4/rpn_class_xxx/truediv:0' shape=(?, ?, 2) dtype=float32&gt;, &lt;tf.Tensor 'rpn_model_4/lambda_3/Reshape:0' shape=(?, ?, 4) dtype=float32&gt;]]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Loop through pyramid layers</span></div><div class="line">    layer_outputs = []  <span class="comment"># list of lists</span></div><div class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> rpn_feature_maps:</div><div class="line">        layer_outputs.append(rpn([p]))</div><div class="line"><span class="comment"># Concatenate layer outputs</span></div><div class="line"><span class="comment"># Convert from list of lists of level outputs to list of lists</span></div><div class="line"><span class="comment"># of outputs across levels.</span></div><div class="line"><span class="comment"># e.g. [[a1, b1, c1], [a2, b2, c2]] =&gt; [[a1, a2], [b1, b2], [c1, c2]]</span></div><div class="line">output_names = [<span class="string">"rpn_class_logits"</span>, <span class="string">"rpn_class"</span>, <span class="string">"rpn_bbox"</span>]</div><div class="line">outputs = list(zip(*layer_outputs))</div><div class="line">outputs = [KL.Concatenate(axis=<span class="number">1</span>, name=n)(list(o))</div><div class="line">           <span class="keyword">for</span> o, n <span class="keyword">in</span> zip(outputs, output_names)]</div><div class="line"></div><div class="line">rpn_class_logits, rpn_class, rpn_bbox = outputs</div></pre></td></tr></table></figure>
<h3 id="RPN-GRAPH"><a href="#RPN-GRAPH" class="headerlink" title="RPN_GRAPH"></a>RPN_GRAPH</h3><p>rpn_logits: [batch, H, W, 2] Anchor classifier logits (before softmax)<br>rpn_probs: [batch, W, W, 2] Anchor classifier probabilities.<br>rpn_bbox: [batch, H, W, (dy, dx, log(dh), log(dw))] Deltas to be applied to anchors.</p>
<p>在上方的時候有執行了這行, 三個參數對應到anchor_stride, anchors_per_location, depth, 為啥要這樣包的原因是因為可以用同樣的weight好幾次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##RPN_ANCHOR_RATIOS = [0.5, 1, 2]</span></div><div class="line"><span class="comment">##RPN_ANCHOR_STRIDE = 1</span></div><div class="line">rpn = build_rpn_model(config.RPN_ANCHOR_STRIDE,</div><div class="line">                              len(config.RPN_ANCHOR_RATIOS), <span class="number">256</span>)</div><div class="line">Input() <span class="keyword">is</span> used to instantiate a Keras tensor.   <span class="comment"># https://www.tensorflow.org/versions/r1.1/api_docs/python/tf/contrib/keras/layers/Input</span></div><div class="line">For instance, <span class="keyword">if</span> a, b <span class="keyword">and</span> c <span class="keyword">and</span> Keras tensors, it becomes possible to do: model = Model(input=[a, b], output=c)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_rpn_model</span><span class="params">(anchor_stride, anchors_per_location, depth)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Builds a Keras model of the Region Proposal Network.</div><div class="line">    It wraps the RPN graph so it can be used multiple times with shared</div><div class="line">    weights.</div><div class="line">    anchors_per_location: number of anchors per pixel in the feature map</div><div class="line">    anchor_stride: Controls the density of anchors. Typically 1 (anchors for</div><div class="line">                   every pixel in the feature map), or 2 (every other pixel).</div><div class="line">    depth: Depth of the backbone feature map.</div><div class="line">    Returns a Keras Model object. The model outputs, when called, are:</div><div class="line">    rpn_logits: [batch, H, W, 2] Anchor classifier logits (before softmax)</div><div class="line">    rpn_probs: [batch, W, W, 2] Anchor classifier probabilities.</div><div class="line">    rpn_bbox: [batch, H, W, (dy, dx, log(dh), log(dw))] Deltas to be</div><div class="line">                applied to anchors.</div><div class="line">    """</div><div class="line">    input_feature_map = KL.Input(shape=[<span class="keyword">None</span>, <span class="keyword">None</span>, depth],</div><div class="line">                                 name=<span class="string">"input_rpn_feature_map"</span>)</div><div class="line">    outputs = rpn_graph(input_feature_map, anchors_per_location, anchor_stride)</div><div class="line">    <span class="keyword">return</span> KM.Model([input_feature_map], outputs, name=<span class="string">"rpn_model"</span>)</div></pre></td></tr></table></figure>
<p>feature map-&gt;Conv(3x3,512)-&gt;RELU 後得到shared feature map<br>接下來就兵分兩路</p>
<p>這邊有點奇怪的是 下面這邊<br>理論上來說應該是要 len(RATIOS)*len(RPN_ANCHOR_SCALES) # 3 x 5<br>但實質上只有3而已</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RPN_ANCHOR_RATIOS = [<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>]</div><div class="line">RPN_ANCHOR_SCALES = (<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>)</div><div class="line">anchors_per_location = len(config.RPN_ANCHOR_RATIOS)</div></pre></td></tr></table></figure>
<p>計算分數<br>shared feature map-&gt;Conv(1x1,2*3)-&gt;linear_activation<br>接著得到的東西會reshape成2xN的樣式的到rpn_class_logits, 接著才做softmax</p>
<pre><code># Reshape to [batch, anchors, 2]
    rpn_class_logits = KL.Lambda(
        lambda t: tf.reshape(t, [tf.shape(t)[0], -1, 2]))(x)
</code></pre><p>計算BBOX 偏移<br>shared feature map-&gt;Conv(1x1,4*3)-&gt;linear_activation<br>接著得到的東西會reshape成2xN的樣式的到rpn_class_logits</p>
<pre><code># Reshape to [batch, anchors, 4]
    rpn_bbox = KL.Lambda(lambda t: tf.reshape(t, [tf.shape(t)[0], -1, 4]))(x)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rpn_graph</span><span class="params">(feature_map, anchors_per_location, anchor_stride)</span>:</span></div><div class="line">    <span class="string">"""Builds the computation graph of Region Proposal Network.</span></div><div class="line">    feature_map: backbone features [batch, height, width, depth]</div><div class="line">    anchors_per_location: number of anchors per pixel in the feature map</div><div class="line">    anchor_stride: Controls the density of anchors. Typically 1 (anchors for</div><div class="line">                   every pixel in the feature map), or 2 (every other pixel).</div><div class="line">    Returns:</div><div class="line">        rpn_logits: [batch, H, W, 2] Anchor classifier logits (before softmax)</div><div class="line">        rpn_probs: [batch, H, W, 2] Anchor classifier probabilities.</div><div class="line">        rpn_bbox: [batch, H, W, (dy, dx, log(dh), log(dw))] Deltas to be</div><div class="line">                  applied to anchors.</div><div class="line">    """</div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span> check if stride of 2 causes alignment issues if the featuremap</span></div><div class="line">    <span class="comment">#       is not even.</span></div><div class="line">    <span class="comment"># Shared convolutional base of the RPN</span></div><div class="line">    shared = KL.Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>,</div><div class="line">                       strides=anchor_stride,</div><div class="line">                       name=<span class="string">'rpn_conv_shared'</span>)(feature_map)</div><div class="line"></div><div class="line">    <span class="comment"># Anchor Score. [batch, height, width, anchors per location * 2].</span></div><div class="line">    x = KL.Conv2D(<span class="number">2</span> * anchors_per_location, (<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>,</div><div class="line">                  activation=<span class="string">'linear'</span>, name=<span class="string">'rpn_class_raw'</span>)(shared)</div><div class="line"></div><div class="line">    <span class="comment"># Reshape to [batch, anchors, 2]</span></div><div class="line">    rpn_class_logits = KL.Lambda(</div><div class="line">        <span class="keyword">lambda</span> t: tf.reshape(t, [tf.shape(t)[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">2</span>]))(x)</div><div class="line"></div><div class="line">    <span class="comment"># Softmax on last dimension of BG/FG.</span></div><div class="line">    rpn_probs = KL.Activation(</div><div class="line">        <span class="string">"softmax"</span>, name=<span class="string">"rpn_class_xxx"</span>)(rpn_class_logits)</div><div class="line"></div><div class="line">    <span class="comment"># Bounding box refinement. [batch, H, W, anchors per location, depth]</span></div><div class="line">    <span class="comment"># where depth is [x, y, log(w), log(h)]</span></div><div class="line">    x = KL.Conv2D(anchors_per_location * <span class="number">4</span>, (<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">"valid"</span>,</div><div class="line">                  activation=<span class="string">'linear'</span>, name=<span class="string">'rpn_bbox_pred'</span>)(shared)</div><div class="line"></div><div class="line">    <span class="comment"># Reshape to [batch, anchors, 4]</span></div><div class="line">    rpn_bbox = KL.Lambda(<span class="keyword">lambda</span> t: tf.reshape(t, [tf.shape(t)[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">4</span>]))(x)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [rpn_class_logits, rpn_probs, rpn_bbox]</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/05/30/Mask-RCNN-Code-Reading-ResNet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/30/Mask-RCNN-Code-Reading-ResNet/" itemprop="url">
                  Mask RCNN Code Reading for ResNet & FPN
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-30T04:54:24+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Mask_RCNN V2.1版本</p>
<p>檔案：<a href="https://github.com/matterport/Mask_RCNN/blob/master/mrcnn/model.py#L85" target="_blank" rel="external">Model.py</a></p>
<p>Resnet的程式碼是由下面這專案參考改來的<br><a href="https://github.com/fchollet/deep-learning-models/blob/master/resnet50.py" target="_blank" rel="external">https://github.com/fchollet/deep-learning-models/blob/master/resnet50.py</a></p>
<h3 id="identity-block"><a href="#identity-block" class="headerlink" title="identity_block"></a>identity_block</h3><p>這function主要是為了後面的resnet_graph做準備的, 主要是為了重複利用,對應到的就是Resnet裡面的identity_block,然後這是純粹的Resnet版本,在shortcut上沒有操作</p>
<p>input_tensor: 其實就是接上一層的output<br>kernel_size : 基本上是3,<br>filters:程式碼中filters通常是一個list, 而通常是三個, 像是[128,128,512],代表三層分別的filter數量<br>stage: 命名用,知道是哪一個stage的<br>block: 命名用,知道是stage中的第幾個idenity_block<br>use_bias: conv layer需不需要bias<br>train_bn: 這個identity_block要freeze還是train</p>
<p>從裡面可以看到一個完整的Identity_Block<br>Input-&gt;(Conv-&gt;BN-&gt;RELU)-&gt;(Conv-&gt;BN-&gt;RELU)-&gt;(Conv-&gt;BN)-&gt;ADD(prev,Input)-&gt;RELU</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">identity_block</span><span class="params">(input_tensor, kernel_size, filters, stage, block,</span></span></div><div class="line">                   use_bias=True, train_bn=True):</div><div class="line">    <span class="string">"""The identity_block is the block that has no conv layer at shortcut</span></div><div class="line">    # Arguments</div><div class="line">        input_tensor: input tensor</div><div class="line">        kernel_size: defualt 3, the kernel size of middle conv layer at main path</div><div class="line">        filters: list of integers, the nb_filters of 3 conv layer at main path</div><div class="line">        stage: integer, current stage label, used for generating layer names</div><div class="line">        block: 'a','b'..., current block label, used for generating layer names</div><div class="line">        use_bias: Boolean. To use or not use a bias in conv layers.</div><div class="line">        train_bn: Boolean. Train or freeze Batch Norm layres</div><div class="line">    """</div><div class="line">    nb_filter1, nb_filter2, nb_filter3 = filters</div><div class="line">    conv_name_base = <span class="string">'res'</span> + str(stage) + block + <span class="string">'_branch'</span></div><div class="line">    bn_name_base = <span class="string">'bn'</span> + str(stage) + block + <span class="string">'_branch'</span></div><div class="line"></div><div class="line">    x = KL.Conv2D(nb_filter1, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base + <span class="string">'2a'</span>,</div><div class="line">                  use_bias=use_bias)(input_tensor)</div><div class="line">    x = BatchNorm(name=bn_name_base + <span class="string">'2a'</span>)(x, training=train_bn)</div><div class="line">    x = KL.Activation(<span class="string">'relu'</span>)(x)</div><div class="line"></div><div class="line">    x = KL.Conv2D(nb_filter2, (kernel_size, kernel_size), padding=<span class="string">'same'</span>,</div><div class="line">                  name=conv_name_base + <span class="string">'2b'</span>, use_bias=use_bias)(x)</div><div class="line">    x = BatchNorm(name=bn_name_base + <span class="string">'2b'</span>)(x, training=train_bn)</div><div class="line">    x = KL.Activation(<span class="string">'relu'</span>)(x)</div><div class="line"></div><div class="line">    x = KL.Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base + <span class="string">'2c'</span>,</div><div class="line">                  use_bias=use_bias)(x)</div><div class="line">    x = BatchNorm(name=bn_name_base + <span class="string">'2c'</span>)(x, training=train_bn)</div><div class="line"></div><div class="line">    x = KL.Add()([x, input_tensor])</div><div class="line">    x = KL.Activation(<span class="string">'relu'</span>, name=<span class="string">'res'</span> + str(stage) + block + <span class="string">'_out'</span>)(x)</div><div class="line">    <span class="keyword">return</span> x</div></pre></td></tr></table></figure>
<h3 id="Conv-block"><a href="#Conv-block" class="headerlink" title="Conv_block"></a>Conv_block</h3><p>這邊就是純粹的Conv_block, input參數與上方相仿, 除了從stage3開始第一個Conv有subsample=(2,2), 而shortcut因此也需要subsample=(2,2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_block</span><span class="params">(input_tensor, kernel_size, filters, stage, block,</span></span></div><div class="line">               strides=<span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span>, use_bias=True, train_bn=True):</div><div class="line">    <span class="string">"""conv_block is the block that has a conv layer at shortcut</span></div><div class="line">    # Arguments</div><div class="line">        input_tensor: input tensor</div><div class="line">        kernel_size: defualt 3, the kernel size of middle conv layer at main path</div><div class="line">        filters: list of integers, the nb_filters of 3 conv layer at main path</div><div class="line">        stage: integer, current stage label, used for generating layer names</div><div class="line">        block: 'a','b'..., current block label, used for generating layer names</div><div class="line">        use_bias: Boolean. To use or not use a bias in conv layers.</div><div class="line">        train_bn: Boolean. Train or freeze Batch Norm layres</div><div class="line">    Note that from stage 3, the first conv layer at main path is with subsample=(2,2)</div><div class="line">    And the shortcut should have subsample=(2,2) as well</div><div class="line">    """</div><div class="line">    nb_filter1, nb_filter2, nb_filter3 = filters</div><div class="line">    conv_name_base = <span class="string">'res'</span> + str(stage) + block + <span class="string">'_branch'</span></div><div class="line">    bn_name_base = <span class="string">'bn'</span> + str(stage) + block + <span class="string">'_branch'</span></div><div class="line"></div><div class="line">    x = KL.Conv2D(nb_filter1, (<span class="number">1</span>, <span class="number">1</span>), strides=strides,</div><div class="line">                  name=conv_name_base + <span class="string">'2a'</span>, use_bias=use_bias)(input_tensor)</div><div class="line">    x = BatchNorm(name=bn_name_base + <span class="string">'2a'</span>)(x, training=train_bn)</div><div class="line">    x = KL.Activation(<span class="string">'relu'</span>)(x)</div><div class="line"></div><div class="line">    x = KL.Conv2D(nb_filter2, (kernel_size, kernel_size), padding=<span class="string">'same'</span>,</div><div class="line">                  name=conv_name_base + <span class="string">'2b'</span>, use_bias=use_bias)(x)</div><div class="line">    x = BatchNorm(name=bn_name_base + <span class="string">'2b'</span>)(x, training=train_bn)</div><div class="line">    x = KL.Activation(<span class="string">'relu'</span>)(x)</div><div class="line"></div><div class="line">    x = KL.Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base +</div><div class="line">                  <span class="string">'2c'</span>, use_bias=use_bias)(x)</div><div class="line">    x = BatchNorm(name=bn_name_base + <span class="string">'2c'</span>)(x, training=train_bn)</div><div class="line"></div><div class="line">    shortcut = KL.Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), strides=strides,</div><div class="line">                         name=conv_name_base + <span class="string">'1'</span>, use_bias=use_bias)(input_tensor)</div><div class="line">    shortcut = BatchNorm(name=bn_name_base + <span class="string">'1'</span>)(shortcut, training=train_bn)</div><div class="line"></div><div class="line">    x = KL.Add()([x, shortcut])</div><div class="line">    x = KL.Activation(<span class="string">'relu'</span>, name=<span class="string">'res'</span> + str(stage) + block + <span class="string">'_out'</span>)(x)</div><div class="line">    <span class="keyword">return</span> x</div></pre></td></tr></table></figure>
<h3 id="Resnet-Graph"><a href="#Resnet-Graph" class="headerlink" title="Resnet_Graph"></a>Resnet_Graph</h3><p>Resnet主體程式碼 剩下就是call上面的function<br>而ResNet50與ResNet101差異就在於中間使用for來判斷要增加幾個identity_block</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet_graph</span><span class="params">(input_image, architecture, stage5=False, train_bn=True)</span>:</span></div><div class="line">    <span class="string">"""Build a ResNet graph.</span></div><div class="line">        architecture: Can be resnet50 or resnet101</div><div class="line">        stage5: Boolean. If False, stage5 of the network is not created</div><div class="line">        train_bn: Boolean. Train or freeze Batch Norm layres</div><div class="line">    """</div><div class="line">    <span class="keyword">assert</span> architecture <span class="keyword">in</span> [<span class="string">"resnet50"</span>, <span class="string">"resnet101"</span>]</div><div class="line">    <span class="comment"># Stage 1</span></div><div class="line">    x = KL.ZeroPadding2D((<span class="number">3</span>, <span class="number">3</span>))(input_image)</div><div class="line">    x = KL.Conv2D(<span class="number">64</span>, (<span class="number">7</span>, <span class="number">7</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">'conv1'</span>, use_bias=<span class="keyword">True</span>)(x)</div><div class="line">    x = BatchNorm(name=<span class="string">'bn_conv1'</span>)(x, training=train_bn)</div><div class="line">    x = KL.Activation(<span class="string">'relu'</span>)(x)</div><div class="line">    C1 = x = KL.MaxPooling2D((<span class="number">3</span>, <span class="number">3</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">"same"</span>)(x)</div><div class="line">    <span class="comment"># Stage 2</span></div><div class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">'a'</span>, strides=(<span class="number">1</span>, <span class="number">1</span>), train_bn=train_bn)</div><div class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">'b'</span>, train_bn=train_bn)</div><div class="line">    C2 = x = identity_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">'c'</span>, train_bn=train_bn)</div><div class="line">    <span class="comment"># Stage 3</span></div><div class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">'a'</span>, train_bn=train_bn)</div><div class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">'b'</span>, train_bn=train_bn)</div><div class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">'c'</span>, train_bn=train_bn)</div><div class="line">    C3 = x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">'d'</span>, train_bn=train_bn)</div><div class="line">    <span class="comment"># Stage 4</span></div><div class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">256</span>, <span class="number">256</span>, <span class="number">1024</span>], stage=<span class="number">4</span>, block=<span class="string">'a'</span>, train_bn=train_bn)</div><div class="line">    block_count = &#123;<span class="string">"resnet50"</span>: <span class="number">5</span>, <span class="string">"resnet101"</span>: <span class="number">22</span>&#125;[architecture]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(block_count):</div><div class="line">        x = identity_block(x, <span class="number">3</span>, [<span class="number">256</span>, <span class="number">256</span>, <span class="number">1024</span>], stage=<span class="number">4</span>, block=chr(<span class="number">98</span> + i), train_bn=train_bn)</div><div class="line">    C4 = x</div><div class="line">    <span class="comment"># Stage 5</span></div><div class="line">    <span class="keyword">if</span> stage5:</div><div class="line">        x = conv_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">'a'</span>, train_bn=train_bn)</div><div class="line">        x = identity_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">'b'</span>, train_bn=train_bn)</div><div class="line">        C5 = x = identity_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">'c'</span>, train_bn=train_bn)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        C5 = <span class="keyword">None</span></div><div class="line">    <span class="keyword">return</span> [C1, C2, C3, C4, C5]</div></pre></td></tr></table></figure>
<h3 id="FPN-Feature-Pyramid-Network"><a href="#FPN-Feature-Pyramid-Network" class="headerlink" title="FPN Feature Pyramid Network"></a>FPN Feature Pyramid Network</h3><p>FPN被寫在了下面 並沒有獨立一個function, 但這邊順便連帶一起講</p>
<p>C5先通過了一個1x1的conv layer調整channel數量,得到P5</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">P5 = KL.Conv2D(<span class="number">256</span>, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">'fpn_c5p5'</span>)(C5)</div></pre></td></tr></table></figure>
<p>接下來P5為了要跟P4層進行運算,所以得resize, 這裡用單純的upsampling, 沒有dialated conv或是transposed conv或是bilinear interpolation.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KL.UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>),name=<span class="string">"fpn_p5upsampled"</span>)(P5)</div></pre></td></tr></table></figure>
<p>所以P4層就是把原本的C4調整過channel數量以後 跟upsamplinge過後的P5相加</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P4 = KL.Add(name=<span class="string">"fpn_p4add"</span>)</div><div class="line">    ([KL.UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">"fpn_p5upsampled"</span>)(P5),</div><div class="line">      KL.Conv2D(<span class="number">256</span>,(<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">'fpn_c4p4'</span>)(C4)])</div></pre></td></tr></table></figure>
<p>FPN完整程式碼如下<br>P6是用來給RPN用的, 不是給FPN用的<br>另外P2~P5又做了一次3x3的conv 是為了消除upsampling的混疊效應 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Build the shared convolutional layers.</span></div><div class="line"><span class="comment"># Bottom-up Layers</span></div><div class="line"><span class="comment"># Returns a list of the last layers of each stage, 5 in total.</span></div><div class="line"><span class="comment"># Don't create the thead (stage 5), so we pick the 4th item in the list.</span></div><div class="line">_, C2, C3, C4, C5 = resnet_graph(input_image, config.BACKBONE,</div><div class="line">                                 stage5=<span class="keyword">True</span>, train_bn=config.TRAIN_BN)</div><div class="line"><span class="comment"># Top-down Layers</span></div><div class="line"><span class="comment"># <span class="doctag">TODO:</span> add assert to varify feature map sizes match what's in config</span></div><div class="line">P5 = KL.Conv2D(<span class="number">256</span>, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">'fpn_c5p5'</span>)(C5)</div><div class="line">P4 = KL.Add(name=<span class="string">"fpn_p4add"</span>)([</div><div class="line">    KL.UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">"fpn_p5upsampled"</span>)(P5),</div><div class="line">    KL.Conv2D(<span class="number">256</span>, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">'fpn_c4p4'</span>)(C4)])</div><div class="line">P3 = KL.Add(name=<span class="string">"fpn_p3add"</span>)([</div><div class="line">    KL.UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">"fpn_p4upsampled"</span>)(P4),</div><div class="line">    KL.Conv2D(<span class="number">256</span>, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">'fpn_c3p3'</span>)(C3)])</div><div class="line">P2 = KL.Add(name=<span class="string">"fpn_p2add"</span>)([</div><div class="line">    KL.UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">"fpn_p3upsampled"</span>)(P3),</div><div class="line">    KL.Conv2D(<span class="number">256</span>, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">'fpn_c2p2'</span>)(C2)])</div><div class="line"><span class="comment"># Attach 3x3 conv to all P layers to get the final feature maps.</span></div><div class="line">P2 = KL.Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">"SAME"</span>, name=<span class="string">"fpn_p2"</span>)(P2)</div><div class="line">P3 = KL.Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">"SAME"</span>, name=<span class="string">"fpn_p3"</span>)(P3)</div><div class="line">P4 = KL.Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">"SAME"</span>, name=<span class="string">"fpn_p4"</span>)(P4)</div><div class="line">P5 = KL.Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">"SAME"</span>, name=<span class="string">"fpn_p5"</span>)(P5)</div><div class="line"><span class="comment"># P6 is used for the 5th anchor scale in RPN. Generated by</span></div><div class="line"><span class="comment"># subsampling from P5 with stride of 2.</span></div><div class="line">P6 = KL.MaxPooling2D(pool_size=(<span class="number">1</span>, <span class="number">1</span>), strides=<span class="number">2</span>, name=<span class="string">"fpn_p6"</span>)(P5)</div><div class="line"></div><div class="line"><span class="comment"># Note that P6 is used in RPN, but not in the classifier heads.</span></div><div class="line">rpn_feature_maps = [P2, P3, P4, P5, P6]</div><div class="line">mrcnn_feature_maps = [P2, P3, P4, P5]</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/05/30/Mask-RCNN-Code-Reading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/30/Mask-RCNN-Code-Reading/" itemprop="url">
                  Mask RCNN Code Reading
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-30T04:52:59+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>BackBone :</p>
<ul>
<li><a href="">ResNet and FPN</a> FPN的code其實作者寫在了model.py的Class MaskRCNN裡面並沒有獨立出來, 而其餘ResNet有</li>
</ul>
<p>Region Proposal Network:</p>
<ul>
<li><a href="">Anchor Boxes Generate</a> 產生anchor boxes的code</li>
<li><a href="">RPN</a> RPN網路架構的code</li>
<li><a href="">Proposal Layer</a> 將Anchor Boxes Generate與RPN結合的部分並會經過NMS</li>
</ul>
<p>TASK_HEAD:</p>
<ul>
<li><a href="">FPN Classifier Graph</a> 有關於<a href="">ROI Align Layer</a>還有分類的網路架構的部分</li>
<li><a href="">Build FPN Mask Graph</a> 有關於<a href="">ROI Align Layer</a>還有Mask的網路架構的部分</li>
<li><a href="">Detection Layer</a> FPN Classifier Graph後,按照confidence還有數量篩選, 算是後處理了</li>
<li><a href="">Detection Target Layer</a> Proposal Layer後,Training的code</li>
<li><a href="">Mask RCNN Loss</a>有關於所有的loss</li>
</ul>
<p>如果是training的話</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> mode == <span class="string">"training"</span>:</div><div class="line">   <span class="comment"># Class ID mask to mark class IDs supported by the dataset the image</span></div><div class="line">   <span class="comment"># came from.</span></div><div class="line">   active_class_ids = KL.Lambda(</div><div class="line">    <span class="keyword">lambda</span> x: parse_image_meta_graph(x)[<span class="string">"active_class_ids"</span>]</div><div class="line">    )(input_image_meta)</div><div class="line">   </div><div class="line">   <span class="keyword">if</span> <span class="keyword">not</span> config.USE_RPN_ROIS:</div><div class="line">    <span class="comment"># Ignore predicted ROIs and use ROIs provided as an input.</span></div><div class="line">    input_rois = KL.Input(shape=[config.POST_NMS_ROIS_TRAINING, <span class="number">4</span>],</div><div class="line">                          name=<span class="string">"input_roi"</span>, dtype=np.int32)</div><div class="line">    <span class="comment"># Normalize coordinates</span></div><div class="line">    target_rois = KL.Lambda(<span class="keyword">lambda</span> x: norm_boxes_graph(</div><div class="line">        x, K.shape(input_image)[<span class="number">1</span>:<span class="number">3</span>]))(input_rois)</div><div class="line">   <span class="keyword">else</span>:</div><div class="line">    target_rois = rpn_rois</div><div class="line">   </div><div class="line">   <span class="comment"># Generate detection targets</span></div><div class="line">   <span class="comment"># Subsamples proposals and generates target outputs for training</span></div><div class="line">   <span class="comment"># Note that proposal class IDs, gt_boxes, and gt_masks are zero</span></div><div class="line">   <span class="comment"># padded. Equally, returned rois and targets are zero padded.</span></div><div class="line">   rois, target_class_ids, target_bbox, target_mask =\</div><div class="line">    DetectionTargetLayer(config, name=<span class="string">"proposal_targets"</span>)([</div><div class="line">        target_rois, input_gt_class_ids, gt_boxes, input_gt_masks])</div><div class="line">   </div><div class="line">   <span class="comment"># Network Heads</span></div><div class="line">   <span class="comment"># <span class="doctag">TODO:</span> verify that this handles zero padded ROIs</span></div><div class="line">   mrcnn_class_logits, mrcnn_class, mrcnn_bbox =\</div><div class="line">    fpn_classifier_graph(rois, mrcnn_feature_maps, input_image_meta,</div><div class="line">                         config.POOL_SIZE, config.NUM_CLASSES,</div><div class="line">                         train_bn=config.TRAIN_BN)</div><div class="line">   </div><div class="line">   mrcnn_mask = build_fpn_mask_graph(rois, mrcnn_feature_maps,</div><div class="line">                                  input_image_meta,</div><div class="line">                                  config.MASK_POOL_SIZE,</div><div class="line">                                  config.NUM_CLASSES,</div><div class="line">                                  train_bn=config.TRAIN_BN)</div><div class="line">   </div><div class="line">   <span class="comment"># <span class="doctag">TODO:</span> clean up (use tf.identify if necessary)</span></div><div class="line">   output_rois = KL.Lambda(<span class="keyword">lambda</span> x: x * <span class="number">1</span>, name=<span class="string">"output_rois"</span>)(rois)</div><div class="line">   </div><div class="line">   <span class="comment"># Losses</span></div><div class="line">   rpn_class_loss = KL.Lambda(<span class="keyword">lambda</span> x: rpn_class_loss_graph(*x), name=<span class="string">"rpn_class_loss"</span>)(</div><div class="line">    [input_rpn_match, rpn_class_logits])</div><div class="line">   rpn_bbox_loss = KL.Lambda(<span class="keyword">lambda</span> x: rpn_bbox_loss_graph(config, *x), name=<span class="string">"rpn_bbox_loss"</span>)(</div><div class="line">    [input_rpn_bbox, input_rpn_match, rpn_bbox])</div><div class="line">   class_loss = KL.Lambda(<span class="keyword">lambda</span> x: mrcnn_class_loss_graph(*x), name=<span class="string">"mrcnn_class_loss"</span>)(</div><div class="line">    [target_class_ids, mrcnn_class_logits, active_class_ids])</div><div class="line">   bbox_loss = KL.Lambda(<span class="keyword">lambda</span> x: mrcnn_bbox_loss_graph(*x), name=<span class="string">"mrcnn_bbox_loss"</span>)(</div><div class="line">    [target_bbox, target_class_ids, mrcnn_bbox])</div><div class="line">   mask_loss = KL.Lambda(<span class="keyword">lambda</span> x: mrcnn_mask_loss_graph(*x), name=<span class="string">"mrcnn_mask_loss"</span>)(</div><div class="line">    [target_mask, target_class_ids, mrcnn_mask])</div><div class="line">   </div><div class="line">   <span class="comment"># Model</span></div><div class="line">   inputs = [input_image, input_image_meta,</div><div class="line">          input_rpn_match, input_rpn_bbox, input_gt_class_ids, input_gt_boxes, input_gt_masks]</div><div class="line">   <span class="keyword">if</span> <span class="keyword">not</span> config.USE_RPN_ROIS:</div><div class="line">    inputs.append(input_rois)</div><div class="line">   outputs = [rpn_class_logits, rpn_class, rpn_bbox,</div><div class="line">           mrcnn_class_logits, mrcnn_class, mrcnn_bbox, mrcnn_mask,</div><div class="line">           rpn_rois, output_rois,</div><div class="line">           rpn_class_loss, rpn_bbox_loss, class_loss, bbox_loss, mask_loss]</div><div class="line">   model = KM.Model(inputs, outputs, name=<span class="string">'mask_rcnn'</span>)</div></pre></td></tr></table></figure>
<p>如果是測試的話</p>
<pre><code class="python"><span class="keyword">else</span>:
    <span class="comment"># Network Heads</span>
    <span class="comment"># Proposal classifier and BBox regressor heads</span>
    mrcnn_class_logits, mrcnn_class, mrcnn_bbox =\
     fpn_classifier_graph(rpn_rois, mrcnn_feature_maps, input_image_meta,
                          config.POOL_SIZE, config.NUM_CLASSES,
                          train_bn=config.TRAIN_BN)

    <span class="comment"># Detections</span>
    <span class="comment"># output is [batch, num_detections, (y1, x1, y2, x2, class_id, score)] in </span>
    <span class="comment"># normalized coordinates</span>
    detections = DetectionLayer(config, name=<span class="string">"mrcnn_detection"</span>)(
     [rpn_rois, mrcnn_class, mrcnn_bbox, input_image_meta])

    <span class="comment"># Create masks for detections</span>
    detection_boxes = KL.Lambda(<span class="keyword">lambda</span> x: x[..., :<span class="number">4</span>])(detections)
    mrcnn_mask = build_fpn_mask_graph(detection_boxes, mrcnn_feature_maps,
                                   input_image_meta,
                                   config.MASK_POOL_SIZE,
                                   config.NUM_CLASSES,
                                   train_bn=config.TRAIN_BN)

    model = KM.Model([input_image, input_image_meta, input_anchors],
                  [detections, mrcnn_class, mrcnn_bbox,
                      mrcnn_mask, rpn_rois, rpn_class, rpn_bbox],
                  name=<span class="string">'mask_rcnn'</span>)
</code></pre>
<p>以下是別人網誌上的舊圖 不太依樣了 build_classfier_grpah拿掉了 上圖是inference下圖是train<br><img src="/media/15280598887927.jpg" alt=""><br><img src="/media/15280601089173.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://world4jason.github.io/2018/04/07/Optimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason Yeh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="world4jason">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/07/Optimize/" itemprop="url">
                  Optimize /
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-07T21:15:01+08:00">
                2018-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Optimize/" itemprop="url" rel="index">
                    <span itemprop="name">Optimize</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jason Yeh" />
          <p class="site-author-name" itemprop="name">Jason Yeh</p>
           
              <p class="site-description motion-element" itemprop="description">菜鳥搬磚日常</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">Kategorien</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason Yeh</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  













  





  

  

  

  

</body>
</html>
